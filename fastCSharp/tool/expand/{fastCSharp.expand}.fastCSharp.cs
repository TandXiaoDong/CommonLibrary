//本文件由程序自动生成,请不要自行修改
using System;
using fastCSharp;

#if NotFastCSharpCode
#else
#pragma warning disable

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(long[] array, int index, int length)
        {
            fixed (long* valueFixed = array)
            {
                for (long* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    long value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long[] reverse(this long[] array)
        {
            if (array == null || array.Length == 0) return nullValue<long>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static long[] GetReverse(long[] array, int index, int length)
        {
            long[] newValues = new long[length];
            fixed (long* valueFixed = array, newValueFixed = newValues)
            {
                for (long* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long[] getReverse(this long[] array)
        {
            if (array == null || array.Length == 0) return nullValue<long>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static long* IndexOf
            (long* valueFixed, int length, long value)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, long value)
        {
            if (array != null)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static long* IndexOf
            (long* valueFixed, int length, Func<long, bool> isValue)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this long[] array, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public unsafe static long firstOrDefault
            (this long[] array, Func<long, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this long[] array, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (long* valueFixed = array)
                {
                    for (long* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static long[] replaceFirst
            (this long[] array, long value, Func<long, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static long[] getArray<valueType>
            (this valueType[] array, Func<valueType, long> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                long[] newValues = new long[array.Length];
                fixed (long* newValueFixed = newValues)
                {
                    long* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<long> GetFind
            (this long[] array, int index, int length, Func<long, bool> isValue)
        {
            long[] newValues = new long[length < sizeof(int) ? sizeof(int) : length];
            fixed (long* newValueFixed = newValues, valueFixed = array)
            {
                long* write = newValueFixed;
                for (long* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<long> getFind
            (this long[] array, Func<long, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this long[] array, Func<long, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static long[] GetFindArray
            (long[] array, int index, int count, Func<long, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (long* valueFixed = array)
            {
                long* startFixed = valueFixed + index, end = startFixed + count;
                for (long* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    long[] newValues = new long[length];
                    fixed (long* newValueFixed = newValues)
                    {
                        long* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static long max(this long[] array, long nullValue)
        {
            long value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long maxKey<valueType>
            (this valueType[] array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, long> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                long maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this long[] array, out long value)
        {
            if (array.length() != 0)
            {
                fixed (long* valueFixed = array)
                {
                    value = *valueFixed;
                    for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static long min(this long[] array, long nullValue)
        {
            long value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, long> getKey, out long value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = long.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long minKey<valueType>
            (this valueType[] array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, long> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                long minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    long nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long[] getReverse(this subArray<long> array)
        {
            if (array.Count == 0) return nullValue<long>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> reverse(this subArray<long> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<long> array, long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public unsafe static long firstOrDefault
            (this subArray<long> array, Func<long, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<long> replaceFirst
            (this subArray<long> array, long value, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<long> find
            (this subArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<long>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<long> getFind
            (this subArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static long[] getFindArray
            (this subArray<long> array, Func<long, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static long[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, long> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                long[] newValues = new long[subArray.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<long> array, Func<long, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (long* arrayFixed = array.UnsafeArray)
                {
                    long* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<long> each
            (this subArray<long> array, Action<long> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    for (long* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<long> array, out long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static long max(this subArray<long> array, long nullValue)
        {
            long value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    long nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                long maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    long nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<long> array, out long value)
        {
            if (array.Count != 0)
            {
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static long min(this subArray<long> array, long nullValue)
        {
            long value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    long nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long minKey<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                long minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    long nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(long[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (long* valueFixed = array)
                {
                    for (long* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (long* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(long));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(uint[] array, int index, int length)
        {
            fixed (uint* valueFixed = array)
            {
                for (uint* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    uint value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint[] reverse(this uint[] array)
        {
            if (array == null || array.Length == 0) return nullValue<uint>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static uint[] GetReverse(uint[] array, int index, int length)
        {
            uint[] newValues = new uint[length];
            fixed (uint* valueFixed = array, newValueFixed = newValues)
            {
                for (uint* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint[] getReverse(this uint[] array)
        {
            if (array == null || array.Length == 0) return nullValue<uint>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static uint* IndexOf
            (uint* valueFixed, int length, uint value)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, uint value)
        {
            if (array != null)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static uint* IndexOf
            (uint* valueFixed, int length, Func<uint, bool> isValue)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this uint[] array, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public unsafe static uint firstOrDefault
            (this uint[] array, Func<uint, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (uint* valueFixed = array)
                {
                    for (uint* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static uint[] replaceFirst
            (this uint[] array, uint value, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static uint[] getArray<valueType>
            (this valueType[] array, Func<valueType, uint> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[array.Length];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<uint> GetFind
            (this uint[] array, int index, int length, Func<uint, bool> isValue)
        {
            uint[] newValues = new uint[length < sizeof(int) ? sizeof(int) : length];
            fixed (uint* newValueFixed = newValues, valueFixed = array)
            {
                uint* write = newValueFixed;
                for (uint* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<uint> getFind
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this uint[] array, Func<uint, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static uint[] GetFindArray
            (uint[] array, int index, int count, Func<uint, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (uint* valueFixed = array)
            {
                uint* startFixed = valueFixed + index, end = startFixed + count;
                for (uint* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    uint[] newValues = new uint[length];
                    fixed (uint* newValueFixed = newValues)
                    {
                        uint* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static uint max(this uint[] array, uint nullValue)
        {
            uint value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint maxKey<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                uint maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this uint[] array, out uint value)
        {
            if (array.length() != 0)
            {
                fixed (uint* valueFixed = array)
                {
                    value = *valueFixed;
                    for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static uint min(this uint[] array, uint nullValue)
        {
            uint value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, out uint value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = uint.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint minKey<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, uint> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                uint minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    uint nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint[] getReverse(this subArray<uint> array)
        {
            if (array.Count == 0) return nullValue<uint>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> reverse(this subArray<uint> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<uint> array, uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public unsafe static uint firstOrDefault
            (this subArray<uint> array, Func<uint, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<uint> replaceFirst
            (this subArray<uint> array, uint value, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<uint> find
            (this subArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<uint>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<uint> getFind
            (this subArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static uint[] getFindArray
            (this subArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static uint[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, uint> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                uint[] newValues = new uint[subArray.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<uint> array, Func<uint, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (uint* arrayFixed = array.UnsafeArray)
                {
                    uint* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<uint> each
            (this subArray<uint> array, Action<uint> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    for (uint* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<uint> array, out uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static uint max(this subArray<uint> array, uint nullValue)
        {
            uint value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    uint nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                uint maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    uint nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<uint> array, out uint value)
        {
            if (array.Count != 0)
            {
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static uint min(this subArray<uint> array, uint nullValue)
        {
            uint value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    uint nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint minKey<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                uint minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    uint nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(uint[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (uint* valueFixed = array)
                {
                    for (uint* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (uint* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(uint));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(int[] array, int index, int length)
        {
            fixed (int* valueFixed = array)
            {
                for (int* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    int value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int[] reverse(this int[] array)
        {
            if (array == null || array.Length == 0) return nullValue<int>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static int[] GetReverse(int[] array, int index, int length)
        {
            int[] newValues = new int[length];
            fixed (int* valueFixed = array, newValueFixed = newValues)
            {
                for (int* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int[] getReverse(this int[] array)
        {
            if (array == null || array.Length == 0) return nullValue<int>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static int* IndexOf
            (int* valueFixed, int length, int value)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, int value)
        {
            if (array != null)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static int* IndexOf
            (int* valueFixed, int length, Func<int, bool> isValue)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this int[] array, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public unsafe static int firstOrDefault
            (this int[] array, Func<int, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this int[] array, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (int* valueFixed = array)
                {
                    for (int* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static int[] replaceFirst
            (this int[] array, int value, Func<int, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static int[] getArray<valueType>
            (this valueType[] array, Func<valueType, int> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                int[] newValues = new int[array.Length];
                fixed (int* newValueFixed = newValues)
                {
                    int* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<int> GetFind
            (this int[] array, int index, int length, Func<int, bool> isValue)
        {
            int[] newValues = new int[length < sizeof(int) ? sizeof(int) : length];
            fixed (int* newValueFixed = newValues, valueFixed = array)
            {
                int* write = newValueFixed;
                for (int* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<int> getFind
            (this int[] array, Func<int, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this int[] array, Func<int, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static int[] GetFindArray
            (int[] array, int index, int count, Func<int, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (int* valueFixed = array)
            {
                int* startFixed = valueFixed + index, end = startFixed + count;
                for (int* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    int[] newValues = new int[length];
                    fixed (int* newValueFixed = newValues)
                    {
                        int* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static int max(this int[] array, int nullValue)
        {
            int value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int maxKey<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, int> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                int maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this int[] array, out int value)
        {
            if (array.length() != 0)
            {
                fixed (int* valueFixed = array)
                {
                    value = *valueFixed;
                    for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static int min(this int[] array, int nullValue)
        {
            int value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, int> getKey, out int value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = int.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int minKey<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, int> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                int minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    int nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int[] getReverse(this subArray<int> array)
        {
            if (array.Count == 0) return nullValue<int>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> reverse(this subArray<int> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<int> array, int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public unsafe static int firstOrDefault
            (this subArray<int> array, Func<int, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<int> replaceFirst
            (this subArray<int> array, int value, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<int> find
            (this subArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<int>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<int> getFind
            (this subArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static int[] getFindArray
            (this subArray<int> array, Func<int, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static int[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, int> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                int[] newValues = new int[subArray.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<int> array, Func<int, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (int* arrayFixed = array.UnsafeArray)
                {
                    int* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<int> each
            (this subArray<int> array, Action<int> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    for (int* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<int> array, out int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static int max(this subArray<int> array, int nullValue)
        {
            int value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    int nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                int maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    int nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<int> array, out int value)
        {
            if (array.Count != 0)
            {
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static int min(this subArray<int> array, int nullValue)
        {
            int value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    int nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int minKey<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                int minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    int nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(int[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (int* valueFixed = array)
                {
                    for (int* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (int* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(int));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(ushort[] array, int index, int length)
        {
            fixed (ushort* valueFixed = array)
            {
                for (ushort* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    ushort value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort[] reverse(this ushort[] array)
        {
            if (array == null || array.Length == 0) return nullValue<ushort>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static ushort[] GetReverse(ushort[] array, int index, int length)
        {
            ushort[] newValues = new ushort[length];
            fixed (ushort* valueFixed = array, newValueFixed = newValues)
            {
                for (ushort* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort[] getReverse(this ushort[] array)
        {
            if (array == null || array.Length == 0) return nullValue<ushort>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, ushort value)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, ushort value)
        {
            if (array != null)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static ushort* IndexOf
            (ushort* valueFixed, int length, Func<ushort, bool> isValue)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public unsafe static ushort firstOrDefault
            (this ushort[] array, Func<ushort, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static ushort[] replaceFirst
            (this ushort[] array, ushort value, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static ushort[] getArray<valueType>
            (this valueType[] array, Func<valueType, ushort> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[array.Length];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<ushort> GetFind
            (this ushort[] array, int index, int length, Func<ushort, bool> isValue)
        {
            ushort[] newValues = new ushort[length < sizeof(int) ? sizeof(int) : length];
            fixed (ushort* newValueFixed = newValues, valueFixed = array)
            {
                ushort* write = newValueFixed;
                for (ushort* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<ushort> getFind
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<ushort>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this ushort[] array, Func<ushort, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static ushort[] GetFindArray
            (ushort[] array, int index, int count, Func<ushort, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (ushort* valueFixed = array)
            {
                ushort* startFixed = valueFixed + index, end = startFixed + count;
                for (ushort* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    ushort[] newValues = new ushort[length];
                    fixed (ushort* newValueFixed = newValues)
                    {
                        ushort* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static ushort max(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort maxKey<valueType>
            (this valueType[] array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, ushort> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                ushort maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this ushort[] array, out ushort value)
        {
            if (array.length() != 0)
            {
                fixed (ushort* valueFixed = array)
                {
                    value = *valueFixed;
                    for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static ushort min(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, ushort> getKey, out ushort value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = ushort.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort minKey<valueType>
            (this valueType[] array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, ushort> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                ushort minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort[] getReverse(this subArray<ushort> array)
        {
            if (array.Count == 0) return nullValue<ushort>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ushort> reverse(this subArray<ushort> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<ushort> array, ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public unsafe static ushort firstOrDefault
            (this subArray<ushort> array, Func<ushort, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<ushort> replaceFirst
            (this subArray<ushort> array, ushort value, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<ushort> find
            (this subArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<ushort>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<ushort> getFind
            (this subArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<ushort>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static ushort[] getFindArray
            (this subArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static ushort[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, ushort> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                ushort[] newValues = new ushort[subArray.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<ushort> array, Func<ushort, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (ushort* arrayFixed = array.UnsafeArray)
                {
                    ushort* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<ushort> each
            (this subArray<ushort> array, Action<ushort> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    for (ushort* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<ushort> array, out ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static ushort max(this subArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    ushort nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                ushort maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    ushort nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<ushort> array, out ushort value)
        {
            if (array.Count != 0)
            {
                fixed (ushort* valueFixed = array.UnsafeArray)
                {
                    ushort* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static ushort min(this subArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    ushort nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort minKey<valueType>
            (this subArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                ushort minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    ushort nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(ushort[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (ushort* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(ushort));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(short[] array, int index, int length)
        {
            fixed (short* valueFixed = array)
            {
                for (short* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    short value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short[] reverse(this short[] array)
        {
            if (array == null || array.Length == 0) return nullValue<short>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static short[] GetReverse(short[] array, int index, int length)
        {
            short[] newValues = new short[length];
            fixed (short* valueFixed = array, newValueFixed = newValues)
            {
                for (short* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short[] getReverse(this short[] array)
        {
            if (array == null || array.Length == 0) return nullValue<short>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static short* IndexOf
            (short* valueFixed, int length, short value)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, short value)
        {
            if (array != null)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static short* IndexOf
            (short* valueFixed, int length, Func<short, bool> isValue)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this short[] array, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public unsafe static short firstOrDefault
            (this short[] array, Func<short, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this short[] array, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (short* valueFixed = array)
                {
                    for (short* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static short[] replaceFirst
            (this short[] array, short value, Func<short, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static short[] getArray<valueType>
            (this valueType[] array, Func<valueType, short> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                short[] newValues = new short[array.Length];
                fixed (short* newValueFixed = newValues)
                {
                    short* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<short> GetFind
            (this short[] array, int index, int length, Func<short, bool> isValue)
        {
            short[] newValues = new short[length < sizeof(int) ? sizeof(int) : length];
            fixed (short* newValueFixed = newValues, valueFixed = array)
            {
                short* write = newValueFixed;
                for (short* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<short> getFind
            (this short[] array, Func<short, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<short>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this short[] array, Func<short, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static short[] GetFindArray
            (short[] array, int index, int count, Func<short, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (short* valueFixed = array)
            {
                short* startFixed = valueFixed + index, end = startFixed + count;
                for (short* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    short[] newValues = new short[length];
                    fixed (short* newValueFixed = newValues)
                    {
                        short* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static short max(this short[] array, short nullValue)
        {
            short value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short maxKey<valueType>
            (this valueType[] array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, short> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                short maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this short[] array, out short value)
        {
            if (array.length() != 0)
            {
                fixed (short* valueFixed = array)
                {
                    value = *valueFixed;
                    for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static short min(this short[] array, short nullValue)
        {
            short value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, short> getKey, out short value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = short.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short minKey<valueType>
            (this valueType[] array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, short> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                short minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    short nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short[] getReverse(this subArray<short> array)
        {
            if (array.Count == 0) return nullValue<short>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<short> reverse(this subArray<short> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<short> array, short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public unsafe static short firstOrDefault
            (this subArray<short> array, Func<short, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<short> replaceFirst
            (this subArray<short> array, short value, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<short> find
            (this subArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<short>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<short> getFind
            (this subArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<short>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static short[] getFindArray
            (this subArray<short> array, Func<short, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static short[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, short> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                short[] newValues = new short[subArray.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<short> array, Func<short, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (short* arrayFixed = array.UnsafeArray)
                {
                    short* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<short> each
            (this subArray<short> array, Action<short> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    for (short* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<short> array, out short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static short max(this subArray<short> array, short nullValue)
        {
            short value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    short nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                short maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    short nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<short> array, out short value)
        {
            if (array.Count != 0)
            {
                fixed (short* valueFixed = array.UnsafeArray)
                {
                    short* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static short min(this subArray<short> array, short nullValue)
        {
            short value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    short nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short minKey<valueType>
            (this subArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                short minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    short nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(short[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (short* valueFixed = array)
                {
                    for (short* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (short* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(short));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(byte[] array, int index, int length)
        {
            fixed (byte* valueFixed = array)
            {
                for (byte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    byte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte[] reverse(this byte[] array)
        {
            if (array == null || array.Length == 0) return nullValue<byte>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static byte[] GetReverse(byte[] array, int index, int length)
        {
            byte[] newValues = new byte[length];
            fixed (byte* valueFixed = array, newValueFixed = newValues)
            {
                for (byte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte[] getReverse(this byte[] array)
        {
            if (array == null || array.Length == 0) return nullValue<byte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static byte* IndexOf
            (byte* valueFixed, int length, byte value)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, byte value)
        {
            if (array != null)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static byte* IndexOf
            (byte* valueFixed, int length, Func<byte, bool> isValue)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this byte[] array, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public unsafe static byte firstOrDefault
            (this byte[] array, Func<byte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (byte* valueFixed = array)
                {
                    for (byte* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static byte[] replaceFirst
            (this byte[] array, byte value, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static byte[] getArray<valueType>
            (this valueType[] array, Func<valueType, byte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[array.Length];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<byte> GetFind
            (this byte[] array, int index, int length, Func<byte, bool> isValue)
        {
            byte[] newValues = new byte[length < sizeof(int) ? sizeof(int) : length];
            fixed (byte* newValueFixed = newValues, valueFixed = array)
            {
                byte* write = newValueFixed;
                for (byte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<byte> getFind
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<byte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this byte[] array, Func<byte, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static byte[] GetFindArray
            (byte[] array, int index, int count, Func<byte, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (byte* valueFixed = array)
            {
                byte* startFixed = valueFixed + index, end = startFixed + count;
                for (byte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    byte[] newValues = new byte[length];
                    fixed (byte* newValueFixed = newValues)
                    {
                        byte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static byte max(this byte[] array, byte nullValue)
        {
            byte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte maxKey<valueType>
            (this valueType[] array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, byte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                byte maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this byte[] array, out byte value)
        {
            if (array.length() != 0)
            {
                fixed (byte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static byte min(this byte[] array, byte nullValue)
        {
            byte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, byte> getKey, out byte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = byte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte minKey<valueType>
            (this valueType[] array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, byte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                byte minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    byte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte[] getReverse(this subArray<byte> array)
        {
            if (array.Count == 0) return nullValue<byte>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<byte> reverse(this subArray<byte> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<byte> array, byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public unsafe static byte firstOrDefault
            (this subArray<byte> array, Func<byte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<byte> replaceFirst
            (this subArray<byte> array, byte value, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<byte> find
            (this subArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<byte>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<byte> getFind
            (this subArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<byte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static byte[] getFindArray
            (this subArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static byte[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, byte> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                byte[] newValues = new byte[subArray.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<byte> array, Func<byte, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (byte* arrayFixed = array.UnsafeArray)
                {
                    byte* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<byte> each
            (this subArray<byte> array, Action<byte> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    for (byte* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<byte> array, out byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static byte max(this subArray<byte> array, byte nullValue)
        {
            byte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    byte nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                byte maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    byte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<byte> array, out byte value)
        {
            if (array.Count != 0)
            {
                fixed (byte* valueFixed = array.UnsafeArray)
                {
                    byte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static byte min(this subArray<byte> array, byte nullValue)
        {
            byte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    byte nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte minKey<valueType>
            (this subArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                byte minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    byte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(byte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (byte* valueFixed = array)
                {
                    for (byte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (byte* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(byte));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(sbyte[] array, int index, int length)
        {
            fixed (sbyte* valueFixed = array)
            {
                for (sbyte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    sbyte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte[] reverse(this sbyte[] array)
        {
            if (array == null || array.Length == 0) return nullValue<sbyte>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static sbyte[] GetReverse(sbyte[] array, int index, int length)
        {
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* valueFixed = array, newValueFixed = newValues)
            {
                for (sbyte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte[] getReverse(this sbyte[] array)
        {
            if (array == null || array.Length == 0) return nullValue<sbyte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, sbyte value)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, sbyte value)
        {
            if (array != null)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static sbyte* IndexOf
            (sbyte* valueFixed, int length, Func<sbyte, bool> isValue)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public unsafe static sbyte firstOrDefault
            (this sbyte[] array, Func<sbyte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static sbyte[] replaceFirst
            (this sbyte[] array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static sbyte[] getArray<valueType>
            (this valueType[] array, Func<valueType, sbyte> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[array.Length];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<sbyte> GetFind
            (this sbyte[] array, int index, int length, Func<sbyte, bool> isValue)
        {
            sbyte[] newValues = new sbyte[length < sizeof(int) ? sizeof(int) : length];
            fixed (sbyte* newValueFixed = newValues, valueFixed = array)
            {
                sbyte* write = newValueFixed;
                for (sbyte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<sbyte> getFind
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<sbyte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static sbyte[] GetFindArray
            (sbyte[] array, int index, int count, Func<sbyte, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (sbyte* valueFixed = array)
            {
                sbyte* startFixed = valueFixed + index, end = startFixed + count;
                for (sbyte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    sbyte[] newValues = new sbyte[length];
                    fixed (sbyte* newValueFixed = newValues)
                    {
                        sbyte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static sbyte max(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte maxKey<valueType>
            (this valueType[] array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                sbyte maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this sbyte[] array, out sbyte value)
        {
            if (array.length() != 0)
            {
                fixed (sbyte* valueFixed = array)
                {
                    value = *valueFixed;
                    for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static sbyte min(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte minKey<valueType>
            (this valueType[] array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                sbyte minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte[] getReverse(this subArray<sbyte> array)
        {
            if (array.Count == 0) return nullValue<sbyte>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<sbyte> reverse(this subArray<sbyte> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<sbyte> array, sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public unsafe static sbyte firstOrDefault
            (this subArray<sbyte> array, Func<sbyte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<sbyte> replaceFirst
            (this subArray<sbyte> array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<sbyte> find
            (this subArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<sbyte>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<sbyte> getFind
            (this subArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<sbyte>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static sbyte[] getFindArray
            (this subArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static sbyte[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, sbyte> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                sbyte[] newValues = new sbyte[subArray.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<sbyte> array, Func<sbyte, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (sbyte* arrayFixed = array.UnsafeArray)
                {
                    sbyte* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<sbyte> each
            (this subArray<sbyte> array, Action<sbyte> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    for (sbyte* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<sbyte> array, out sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static sbyte max(this subArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    sbyte nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                sbyte maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<sbyte> array, out sbyte value)
        {
            if (array.Count != 0)
            {
                fixed (sbyte* valueFixed = array.UnsafeArray)
                {
                    sbyte* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static sbyte min(this subArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    sbyte nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte minKey<valueType>
            (this subArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                sbyte minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    sbyte nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(sbyte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (sbyte* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(sbyte));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(double[] array, int index, int length)
        {
            fixed (double* valueFixed = array)
            {
                for (double* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    double value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] reverse(this double[] array)
        {
            if (array == null || array.Length == 0) return nullValue<double>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static double[] GetReverse(double[] array, int index, int length)
        {
            double[] newValues = new double[length];
            fixed (double* valueFixed = array, newValueFixed = newValues)
            {
                for (double* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getReverse(this double[] array)
        {
            if (array == null || array.Length == 0) return nullValue<double>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static double* IndexOf
            (double* valueFixed, int length, double value)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, double value)
        {
            if (array != null)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static double* IndexOf
            (double* valueFixed, int length, Func<double, bool> isValue)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this double[] array, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public unsafe static double firstOrDefault
            (this double[] array, Func<double, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this double[] array, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (double* valueFixed = array)
                {
                    for (double* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static double[] replaceFirst
            (this double[] array, double value, Func<double, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static double[] getArray<valueType>
            (this valueType[] array, Func<valueType, double> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                double[] newValues = new double[array.Length];
                fixed (double* newValueFixed = newValues)
                {
                    double* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<double> GetFind
            (this double[] array, int index, int length, Func<double, bool> isValue)
        {
            double[] newValues = new double[length < sizeof(int) ? sizeof(int) : length];
            fixed (double* newValueFixed = newValues, valueFixed = array)
            {
                double* write = newValueFixed;
                for (double* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<double> getFind
            (this double[] array, Func<double, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this double[] array, Func<double, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static double[] GetFindArray
            (double[] array, int index, int count, Func<double, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (double* valueFixed = array)
            {
                double* startFixed = valueFixed + index, end = startFixed + count;
                for (double* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    double[] newValues = new double[length];
                    fixed (double* newValueFixed = newValues)
                    {
                        double* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static double max(this double[] array, double nullValue)
        {
            double value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double maxKey<valueType>
            (this valueType[] array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, double> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                double maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this double[] array, out double value)
        {
            if (array.length() != 0)
            {
                fixed (double* valueFixed = array)
                {
                    value = *valueFixed;
                    for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static double min(this double[] array, double nullValue)
        {
            double value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, double> getKey, out double value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = double.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double minKey<valueType>
            (this valueType[] array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, double> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                double minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    double nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getReverse(this subArray<double> array)
        {
            if (array.Count == 0) return nullValue<double>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> reverse(this subArray<double> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<double> array, double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public unsafe static double firstOrDefault
            (this subArray<double> array, Func<double, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<double> replaceFirst
            (this subArray<double> array, double value, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<double> find
            (this subArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<double>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<double> getFind
            (this subArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static double[] getFindArray
            (this subArray<double> array, Func<double, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static double[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, double> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                double[] newValues = new double[subArray.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<double> array, Func<double, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (double* arrayFixed = array.UnsafeArray)
                {
                    double* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<double> each
            (this subArray<double> array, Action<double> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    for (double* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<double> array, out double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static double max(this subArray<double> array, double nullValue)
        {
            double value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    double nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                double maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    double nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<double> array, out double value)
        {
            if (array.Count != 0)
            {
                fixed (double* valueFixed = array.UnsafeArray)
                {
                    double* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static double min(this subArray<double> array, double nullValue)
        {
            double value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    double nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double minKey<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                double minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    double nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(double[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (double* valueFixed = array)
                {
                    for (double* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (double* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(double));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(float[] array, int index, int length)
        {
            fixed (float* valueFixed = array)
            {
                for (float* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    float value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] reverse(this float[] array)
        {
            if (array == null || array.Length == 0) return nullValue<float>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static float[] GetReverse(float[] array, int index, int length)
        {
            float[] newValues = new float[length];
            fixed (float* valueFixed = array, newValueFixed = newValues)
            {
                for (float* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getReverse(this float[] array)
        {
            if (array == null || array.Length == 0) return nullValue<float>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static float* IndexOf
            (float* valueFixed, int length, float value)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, float value)
        {
            if (array != null)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static float* IndexOf
            (float* valueFixed, int length, Func<float, bool> isValue)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this float[] array, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public unsafe static float firstOrDefault
            (this float[] array, Func<float, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this float[] array, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (float* valueFixed = array)
                {
                    for (float* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static float[] replaceFirst
            (this float[] array, float value, Func<float, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static float[] getArray<valueType>
            (this valueType[] array, Func<valueType, float> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                float[] newValues = new float[array.Length];
                fixed (float* newValueFixed = newValues)
                {
                    float* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<float> GetFind
            (this float[] array, int index, int length, Func<float, bool> isValue)
        {
            float[] newValues = new float[length < sizeof(int) ? sizeof(int) : length];
            fixed (float* newValueFixed = newValues, valueFixed = array)
            {
                float* write = newValueFixed;
                for (float* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<float> getFind
            (this float[] array, Func<float, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this float[] array, Func<float, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static float[] GetFindArray
            (float[] array, int index, int count, Func<float, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (float* valueFixed = array)
            {
                float* startFixed = valueFixed + index, end = startFixed + count;
                for (float* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    float[] newValues = new float[length];
                    fixed (float* newValueFixed = newValues)
                    {
                        float* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static float max(this float[] array, float nullValue)
        {
            float value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float maxKey<valueType>
            (this valueType[] array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, float> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                float maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this float[] array, out float value)
        {
            if (array.length() != 0)
            {
                fixed (float* valueFixed = array)
                {
                    value = *valueFixed;
                    for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static float min(this float[] array, float nullValue)
        {
            float value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, float> getKey, out float value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = float.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float minKey<valueType>
            (this valueType[] array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, float> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                float minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    float nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getReverse(this subArray<float> array)
        {
            if (array.Count == 0) return nullValue<float>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> reverse(this subArray<float> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<float> array, float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public unsafe static float firstOrDefault
            (this subArray<float> array, Func<float, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<float> replaceFirst
            (this subArray<float> array, float value, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<float> find
            (this subArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<float>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<float> getFind
            (this subArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static float[] getFindArray
            (this subArray<float> array, Func<float, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static float[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, float> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                float[] newValues = new float[subArray.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<float> array, Func<float, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (float* arrayFixed = array.UnsafeArray)
                {
                    float* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<float> each
            (this subArray<float> array, Action<float> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    for (float* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<float> array, out float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static float max(this subArray<float> array, float nullValue)
        {
            float value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    float nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                float maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    float nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<float> array, out float value)
        {
            if (array.Count != 0)
            {
                fixed (float* valueFixed = array.UnsafeArray)
                {
                    float* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static float min(this subArray<float> array, float nullValue)
        {
            float value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    float nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float minKey<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                float minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    float nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(float[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (float* valueFixed = array)
                {
                    for (float* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (float* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(float));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal unsafe static void Reverse(DateTime[] array, int index, int length)
        {
            fixed (DateTime* valueFixed = array)
            {
                for (DateTime* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    DateTime value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime[] reverse(this DateTime[] array)
        {
            if (array == null || array.Length == 0) return nullValue<DateTime>.Array;
            Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal unsafe static DateTime[] GetReverse(DateTime[] array, int index, int length)
        {
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* valueFixed = array, newValueFixed = newValues)
            {
                for (DateTime* start = valueFixed + index, end = start + length, wirte = newValueFixed + length;
                    start != end;
                    *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime[] getReverse(this DateTime[] array)
        {
            if (array == null || array.Length == 0) return nullValue<DateTime>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, DateTime value)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, DateTime value)
        {
            if (array != null)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal unsafe static DateTime* IndexOf
            (DateTime* valueFixed, int length, Func<DateTime, bool> isValue)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public unsafe static DateTime firstOrDefault
            (this DateTime[] array, Func<DateTime, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* end = valueFixed + array.Length; end != valueFixed; )
                    {
                        if (isValue(*--end)) ++value;
                    }
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static DateTime[] replaceFirst
            (this DateTime[] array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
                return array;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static DateTime[] getArray<valueType>
            (this valueType[] array, Func<valueType, DateTime> getValue)
        {
            if (array.length() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[array.Length];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* writeValue = newValueFixed;
                    foreach (valueType value in array) *writeValue++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal unsafe static subArray<DateTime> GetFind
            (this DateTime[] array, int index, int length, Func<DateTime, bool> isValue)
        {
            DateTime[] newValues = new DateTime[length < sizeof(int) ? sizeof(int) : length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = array)
            {
                DateTime* write = newValueFixed;
                for (DateTime* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return subArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<DateTime> getFind
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array.length() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return GetFind(array, 0, array.Length, isValue);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (isValue == null) log.Error.Throw(log.exceptionType.Null);
            int length = array.length();
            if (length != 0)
            {
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length = ((length + 31) >> 5) << 2);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return GetFindArray(array, 0, array.Length, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal unsafe static DateTime[] GetFindArray
            (DateTime[] array, int index, int count, Func<DateTime, bool> isValue, fixedMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (DateTime* valueFixed = array)
            {
                DateTime* startFixed = valueFixed + index, end = startFixed + count;
                for (DateTime* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    DateTime[] newValues = new DateTime[length];
                    fixed (DateTime* newValueFixed = newValues)
                    {
                        DateTime* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex)) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static DateTime max(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime maxKey<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                DateTime maxKey = getKey(value = array[0]);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this DateTime[] array, out DateTime value)
        {
            if (array.length() != 0)
            {
                fixed (DateTime* valueFixed = array)
                {
                    value = *valueFixed;
                    for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static DateTime min(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.length() != 0)
            {
                value = getKey(array[0]);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MaxValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime minKey<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.length() != 0)
            {
                value = array[0];
                DateTime minKey = getKey(value);
                foreach (valueType nextValue in array)
                {
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime[] getReverse(this subArray<DateTime> array)
        {
            if (array.Count == 0) return nullValue<DateTime>.Array;
            return arrayExtension.GetReverse(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> reverse(this subArray<DateTime> array)
        {
            if (array.Count > 1) arrayExtension.Reverse(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<DateTime> array, DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public unsafe static int indexOf(this subArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, index = arrayExtension.IndexOf(start, array.Count, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public unsafe static DateTime firstOrDefault
            (this subArray<DateTime> array, Func<DateTime, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Count)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex + index, array.Count - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public unsafe static int count(this subArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int value = 0;
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    do
                    {
                        if (isValue(*start)) ++value;
                    }
                    while (++start != end);
                }
                return value;
            }
            return 0;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public unsafe static subArray<DateTime> replaceFirst
            (this subArray<DateTime> array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* valueIndex = arrayExtension.IndexOf(valueFixed + array.StartIndex, array.Count, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public unsafe static subArray<DateTime> find
            (this subArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* write = valueFixed + array.StartIndex, start = write, end = write + array.Count;
                    do
                    {
                        if (isValue(*start)) *write++ = *start;
                    }
                    while (++start != end);
                    return subArray<DateTime>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static subArray<DateTime> getFind
            (this subArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                return arrayExtension.GetFind(array.UnsafeArray, array.StartIndex, array.Count, isValue);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public unsafe static DateTime[] getFindArray
            (this subArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Count != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int length = ((array.Count + 31) >> 5) << 2;
                memoryPool pool = fastCSharp.memoryPool.GetDefaultPool(length);
                byte[] data = pool.Get(length);
                try
                {
                    fixed (byte* dataFixed = data)
                    {
                        Array.Clear(data, 0, length);
                        return arrayExtension.GetFindArray(array.UnsafeArray, array.StartIndex, array.Count, isValue, new fixedMap(dataFixed));
                    }
                }
                finally { pool.PushNotNull(data); }
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static DateTime[] getArray<valueType>
            (this subArray<valueType> subArray, Func<valueType, DateTime> getValue)
        {
            if (subArray.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] array = subArray.UnsafeArray;
                DateTime[] newValues = new DateTime[subArray.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    int index = subArray.StartIndex, endIndex = index + subArray.Count;
                    do
                    {
                        *write++ = getValue(array[index++]);
                    }
                    while (index != endIndex);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public unsafe static valueType[] getArray<valueType>
            (this subArray<DateTime> array, Func<DateTime, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] newValues = new valueType[array.Count];
                fixed (DateTime* arrayFixed = array.UnsafeArray)
                {
                    DateTime* start = arrayFixed + array.StartIndex, end = start + array.Count;
                    int index = 0;
                    do
                    {
                        newValues[index++] = getValue(*start);
                    }
                    while (++start != end);
                }
                return newValues;
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public unsafe static subArray<DateTime> each
            (this subArray<DateTime> array, Action<DateTime> method)
        {
            if (array.Count != 0)
            {
                if (method == null) log.Error.Throw(log.exceptionType.Null);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    for (DateTime* start = valueFixed + array.StartIndex, end = start + array.Count; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public unsafe static bool max(this subArray<DateTime> array, out DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start > value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static DateTime max(this subArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    DateTime nextKey = getKey(array[index]);
                    if (nextKey > value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime maxKey<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this subArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                DateTime maxKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey > maxKey)
                    {
                        maxKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>(this subArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public unsafe static bool min(this subArray<DateTime> array, out DateTime value)
        {
            if (array.Count != 0)
            {
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    for (value = *start; ++start != end; )
                    {
                        if (*start < value) value = *start;
                    }
                    return true;
                }
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static DateTime min(this subArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this subArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                value = getKey(array[index]);
                while (++index != endIndex)
                {
                    DateTime nextKey = getKey(array[index]);
                    if (nextKey < value) value = nextKey;
                }
                return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime minKey<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this subArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Count != 0)
            {
                valueType[] array = subArray.UnsafeArray;
                int index = subArray.StartIndex, endIndex = index + subArray.Count;
                DateTime minKey = getKey(value = array[index]);
                while (++index != endIndex)
                {
                    valueType nextValue = array[index];
                    DateTime nextKey = getKey(nextValue);
                    if (nextKey < minKey)
                    {
                        minKey = nextKey;
                        value = nextValue;
                    }
                }
                return true;
            }
            value = default(valueType);
            return false;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>(this subArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.unsafer
{
    /// <summary>
    /// 数组非安全扩展操作(请自行确保数据可靠性)
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if MONO
#else
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
#endif
        public unsafe static void Move(DateTime[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (DateTime* valueFixed = array) win32.kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(DateTime));
#endif
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<long> distinct(this long[] array)
        {
            if (array == null) return default(subArray<long>);
            if (array.Length <= 1) return subArray<long>.Unsafe(array, 0, array.Length);
            arrayExtension.sort(array, 0, array.Length);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return subArray<long>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] distinct<valueType>
            (this long[] array, Func<long, valueType> getValue)
        {
            return new subArray<long>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static subArray<long> distinct<valueType>
            (this valueType[] array, Func<valueType, long> getValue)
        {
            if (getValue == null) log.Error.Throw(log.exceptionType.Null);
            long[] newValues = array.getArray(getValue);
            arrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static subArray<long> intersect(this long[] left, long[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                long[] min = leftLength <= rightLength ? left : right, values = new long[min.Length];
                fixed (long* valueFixed = values)
                {
                    long* write = valueFixed;
                    staticHashSet<long> hash = new staticHashSet<long>(min);
                    foreach (long value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return subArray<long>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static keyValue<long, int>[] sortGroupCount(this long[] array)
        {
            return new subArray<long>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<subArray<valueType>> sortGroup<valueType>
            (this valueType[] array, Func<valueType, long> getValue)
        {
            return new subArray<valueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int sortGroupCount<valueType>
            (this valueType[] array, Func<valueType, long> getValue)
        {
            return new subArray<valueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<long> distinct(this subArray<long> array)
        {
            if (array.Count > 1)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return subArray<long>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static valueType[] distinct<valueType>
            (this subArray<long> array, Func<long, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, end = start + array.Count;
                    long value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    valueType[] values = new valueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<long> distinct<valueType>
            (this subArray<valueType> array, Func<valueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                long[] newValues = array.getArray(getValue);
                arrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static keyValue<long, int>[] sortGroupCount(this subArray<long> array)
        {
            if (array.Count != 0)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (long* valueFixed = array.UnsafeArray)
                {
                    long* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    long value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    keyValue<long, int>[] values = new keyValue<long, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return nullValue<keyValue<long, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<subArray<valueType>> sortGroup<valueType>
            (this subArray<valueType> array, Func<valueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                subArray<valueType>[] values = new subArray<valueType>[sortArray.Length];
                long key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    long nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return subArray<subArray<valueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(subArray<subArray<valueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<valueType>
            (this subArray<valueType> array, Func<valueType, long> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                long key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    long nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<uint> distinct(this uint[] array)
        {
            if (array == null) return default(subArray<uint>);
            if (array.Length <= 1) return subArray<uint>.Unsafe(array, 0, array.Length);
            arrayExtension.sort(array, 0, array.Length);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return subArray<uint>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] distinct<valueType>
            (this uint[] array, Func<uint, valueType> getValue)
        {
            return new subArray<uint>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static subArray<uint> distinct<valueType>
            (this valueType[] array, Func<valueType, uint> getValue)
        {
            if (getValue == null) log.Error.Throw(log.exceptionType.Null);
            uint[] newValues = array.getArray(getValue);
            arrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static subArray<uint> intersect(this uint[] left, uint[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                uint[] min = leftLength <= rightLength ? left : right, values = new uint[min.Length];
                fixed (uint* valueFixed = values)
                {
                    uint* write = valueFixed;
                    staticHashSet<uint> hash = new staticHashSet<uint>(min);
                    foreach (uint value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return subArray<uint>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static keyValue<uint, int>[] sortGroupCount(this uint[] array)
        {
            return new subArray<uint>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<subArray<valueType>> sortGroup<valueType>
            (this valueType[] array, Func<valueType, uint> getValue)
        {
            return new subArray<valueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int sortGroupCount<valueType>
            (this valueType[] array, Func<valueType, uint> getValue)
        {
            return new subArray<valueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<uint> distinct(this subArray<uint> array)
        {
            if (array.Count > 1)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return subArray<uint>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static valueType[] distinct<valueType>
            (this subArray<uint> array, Func<uint, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, end = start + array.Count;
                    uint value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    valueType[] values = new valueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<uint> distinct<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                uint[] newValues = array.getArray(getValue);
                arrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static keyValue<uint, int>[] sortGroupCount(this subArray<uint> array)
        {
            if (array.Count != 0)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (uint* valueFixed = array.UnsafeArray)
                {
                    uint* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    uint value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    keyValue<uint, int>[] values = new keyValue<uint, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return nullValue<keyValue<uint, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<subArray<valueType>> sortGroup<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                subArray<valueType>[] values = new subArray<valueType>[sortArray.Length];
                uint key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    uint nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return subArray<subArray<valueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(subArray<subArray<valueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                uint key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    uint nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<int> distinct(this int[] array)
        {
            if (array == null) return default(subArray<int>);
            if (array.Length <= 1) return subArray<int>.Unsafe(array, 0, array.Length);
            arrayExtension.sort(array, 0, array.Length);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return subArray<int>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] distinct<valueType>
            (this int[] array, Func<int, valueType> getValue)
        {
            return new subArray<int>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static subArray<int> distinct<valueType>
            (this valueType[] array, Func<valueType, int> getValue)
        {
            if (getValue == null) log.Error.Throw(log.exceptionType.Null);
            int[] newValues = array.getArray(getValue);
            arrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static subArray<int> intersect(this int[] left, int[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                int[] min = leftLength <= rightLength ? left : right, values = new int[min.Length];
                fixed (int* valueFixed = values)
                {
                    int* write = valueFixed;
                    staticHashSet<int> hash = new staticHashSet<int>(min);
                    foreach (int value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return subArray<int>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static keyValue<int, int>[] sortGroupCount(this int[] array)
        {
            return new subArray<int>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<subArray<valueType>> sortGroup<valueType>
            (this valueType[] array, Func<valueType, int> getValue)
        {
            return new subArray<valueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int sortGroupCount<valueType>
            (this valueType[] array, Func<valueType, int> getValue)
        {
            return new subArray<valueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<int> distinct(this subArray<int> array)
        {
            if (array.Count > 1)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return subArray<int>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static valueType[] distinct<valueType>
            (this subArray<int> array, Func<int, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, end = start + array.Count;
                    int value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    valueType[] values = new valueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<int> distinct<valueType>
            (this subArray<valueType> array, Func<valueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                int[] newValues = array.getArray(getValue);
                arrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static keyValue<int, int>[] sortGroupCount(this subArray<int> array)
        {
            if (array.Count != 0)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (int* valueFixed = array.UnsafeArray)
                {
                    int* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    int value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    keyValue<int, int>[] values = new keyValue<int, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return nullValue<keyValue<int, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<subArray<valueType>> sortGroup<valueType>
            (this subArray<valueType> array, Func<valueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                subArray<valueType>[] values = new subArray<valueType>[sortArray.Length];
                int key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    int nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return subArray<subArray<valueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(subArray<subArray<valueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<valueType>
            (this subArray<valueType> array, Func<valueType, int> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                int key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    int nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<DateTime> distinct(this DateTime[] array)
        {
            if (array == null) return default(subArray<DateTime>);
            if (array.Length <= 1) return subArray<DateTime>.Unsafe(array, 0, array.Length);
            arrayExtension.sort(array, 0, array.Length);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + 1, end = valueFixed + array.Length, write = valueFixed;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return subArray<DateTime>.Unsafe(array, 0, (int)(write - valueFixed) + 1);
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] distinct<valueType>
            (this DateTime[] array, Func<DateTime, valueType> getValue)
        {
            return new subArray<DateTime>(array).distinct(getValue);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public static subArray<DateTime> distinct<valueType>
            (this valueType[] array, Func<valueType, DateTime> getValue)
        {
            if (getValue == null) log.Error.Throw(log.exceptionType.Null);
            DateTime[] newValues = array.getArray(getValue);
            arrayExtension.sort(newValues, 0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 求交集
        /// </summary>
        /// <param name="left">左侧数据</param>
        /// <param name="right">右侧数据</param>
        /// <returns>数据交集</returns>
        public unsafe static subArray<DateTime> intersect(this DateTime[] left, DateTime[] right)
        {
            int leftLength = left.length(), rightLength = right.length();
            if (leftLength != 0 && rightLength != 0)
            {
                DateTime[] min = leftLength <= rightLength ? left : right, values = new DateTime[min.Length];
                fixed (DateTime* valueFixed = values)
                {
                    DateTime* write = valueFixed;
                    staticHashSet<DateTime> hash = new staticHashSet<DateTime>(min);
                    foreach (DateTime value in leftLength <= rightLength ? right : left)
                    {
                        if (hash.Contains(value)) *write++ = value;
                    }
                    return subArray<DateTime>.Unsafe(values, 0, (int)(write - valueFixed));
                }
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static keyValue<DateTime, int>[] sortGroupCount(this DateTime[] array)
        {
            return new subArray<DateTime>(array).sortGroupCount();
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<subArray<valueType>> sortGroup<valueType>
            (this valueType[] array, Func<valueType, DateTime> getValue)
        {
            return new subArray<valueType>(array).sortGroup(getValue);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int sortGroupCount<valueType>
            (this valueType[] array, Func<valueType, DateTime> getValue)
        {
            return new subArray<valueType>(array).sortGroupCount(getValue);
        }
    }
    
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<DateTime> distinct(this subArray<DateTime> array)
        {
            if (array.Count > 1)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* write = valueFixed + array.StartIndex, start = write + 1, end = write + array.Count;
                    do
                    {
                        if (*start != *write) *++write = *start;
                    }
                    while (++start != end);
                    return subArray<DateTime>.Unsafe(array.UnsafeArray, array.StartIndex, (int)(write - valueFixed) + 1 - array.StartIndex);
                }
            }
            return array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static valueType[] distinct<valueType>
            (this subArray<DateTime> array, Func<DateTime, valueType> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, end = start + array.Count;
                    DateTime value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    valueType[] values = new valueType[count];
                    values[0] = getValue(value = *(start = valueFixed + array.StartIndex));
                    count = 1;
                    while (++start != end)
                    {
                        if (*start != value) values[count++] = getValue(value = *start);
                    }
                    return values;
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<DateTime> distinct<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                DateTime[] newValues = array.getArray(getValue);
                arrayExtension.sort(newValues, 0, newValues.Length);
                return newValues.distinct();
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        public unsafe static keyValue<DateTime, int>[] sortGroupCount(this subArray<DateTime> array)
        {
            if (array.Count != 0)
            {
                arrayExtension.sort(array.UnsafeArray, array.StartIndex, array.Count);
                fixed (DateTime* valueFixed = array.UnsafeArray)
                {
                    DateTime* start = valueFixed + array.StartIndex, lastStart = start, end = start + array.Count;
                    DateTime value = *start;
                    int count = 1;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            ++count;
                            value = *start;
                        }
                    }
                    keyValue<DateTime, int>[] values = new keyValue<DateTime, int>[count];
                    value = *(start = lastStart);
                    count = 0;
                    while (++start != end)
                    {
                        if (*start != value)
                        {
                            values[count++].Set(value, (int)(start - lastStart));
                            value = *start;
                            lastStart = start;
                        }
                    }
                    values[count].Set(value, (int)(start - lastStart));
                    return values;
                }
            }
            return nullValue<keyValue<DateTime, int>>.Array;
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        public unsafe static subArray<subArray<valueType>> sortGroup<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                subArray<valueType>[] values = new subArray<valueType>[sortArray.Length];
                DateTime key = getValue(sortArray[0]);
                int startIndex = 0, valueIndex = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    DateTime nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        values[valueIndex++].UnsafeSet(sortArray, startIndex, index - startIndex);
                        key = nextKey;
                        startIndex = index;
                    }
                }
                values[valueIndex++].UnsafeSet(sortArray, startIndex, sortArray.Length - startIndex);
                return subArray<subArray<valueType>>.Unsafe(values, 0, valueIndex);
            }
            return default(subArray<subArray<valueType>>);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        public unsafe static int sortGroupCount<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            if (array.Count != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                valueType[] sortArray = arrayExtension.getSort(array.UnsafeArray, getValue, array.StartIndex, array.Count);
                DateTime key = getValue(sortArray[0]);
                int count = 0;
                for (int index = 1; index != sortArray.Length; ++index)
                {
                    DateTime nextKey = getValue(sortArray[index]);
                    if (key != nextKey)
                    {
                        ++count;
                        key = nextKey;
                    }
                }
                return count + 1;
            }
            return 0;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray
            (this System.Collections.Generic.ICollection<long> values)
        {
            if (values.count() != 0)
            {
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static long[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, long> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<long> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, long> getValue)
        {
            return values != null ? new list<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<long> getList(this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new list<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<long> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, long> getValue)
        {
            return values != null ? new collection<long>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<long> getCollection
            (this System.Collections.Generic.ICollection<long> values)
        {
            return values != null ? new collection<long>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<long> getFind
            (this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<long> getFind
            (this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                long[] newValues = new long[values.Count];
                fixed (long* newValueFixed = newValues)
                {
                    long* write = newValueFixed;
                    foreach (long value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<long>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long[] getFindArray
            (this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long[] getFindArray
            (this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray
            (this System.Collections.Generic.ICollection<uint> values)
        {
            if (values.count() != 0)
            {
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static uint[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, uint> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<uint> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, uint> getValue)
        {
            return values != null ? new list<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<uint> getList(this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new list<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<uint> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, uint> getValue)
        {
            return values != null ? new collection<uint>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<uint> getCollection
            (this System.Collections.Generic.ICollection<uint> values)
        {
            return values != null ? new collection<uint>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<uint> getFind
            (this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<uint> getFind
            (this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                uint[] newValues = new uint[values.Count];
                fixed (uint* newValueFixed = newValues)
                {
                    uint* write = newValueFixed;
                    foreach (uint value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<uint>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint[] getFindArray
            (this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint[] getFindArray
            (this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray
            (this System.Collections.Generic.ICollection<int> values)
        {
            if (values.count() != 0)
            {
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static int[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, int> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<int> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, int> getValue)
        {
            return values != null ? new list<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<int> getList(this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new list<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<int> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, int> getValue)
        {
            return values != null ? new collection<int>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<int> getCollection
            (this System.Collections.Generic.ICollection<int> values)
        {
            return values != null ? new collection<int>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<int> getFind
            (this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<int> getFind
            (this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                int[] newValues = new int[values.Count];
                fixed (int* newValueFixed = newValues)
                {
                    int* write = newValueFixed;
                    foreach (int value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<int>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int[] getFindArray
            (this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int[] getFindArray
            (this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            if (values.count() != 0)
            {
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static ushort[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, ushort> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<ushort>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<ushort> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, ushort> getValue)
        {
            return values != null ? new list<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<ushort> getList(this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new list<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<ushort> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, ushort> getValue)
        {
            return values != null ? new collection<ushort>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<ushort> getCollection
            (this System.Collections.Generic.ICollection<ushort> values)
        {
            return values != null ? new collection<ushort>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<ushort> getFind
            (this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<ushort>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<ushort> getFind
            (this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                ushort[] newValues = new ushort[values.Count];
                fixed (ushort* newValueFixed = newValues)
                {
                    ushort* write = newValueFixed;
                    foreach (ushort value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<ushort>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<ushort>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort[] getFindArray
            (this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort[] getFindArray
            (this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray
            (this System.Collections.Generic.ICollection<short> values)
        {
            if (values.count() != 0)
            {
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static short[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, short> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<short>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<short> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, short> getValue)
        {
            return values != null ? new list<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<short> getList(this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new list<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<short> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, short> getValue)
        {
            return values != null ? new collection<short>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<short> getCollection
            (this System.Collections.Generic.ICollection<short> values)
        {
            return values != null ? new collection<short>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<short> getFind
            (this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<short>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<short> getFind
            (this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                short[] newValues = new short[values.Count];
                fixed (short* newValueFixed = newValues)
                {
                    short* write = newValueFixed;
                    foreach (short value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<short>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<short>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short[] getFindArray
            (this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short[] getFindArray
            (this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray
            (this System.Collections.Generic.ICollection<byte> values)
        {
            if (values.count() != 0)
            {
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static byte[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, byte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<byte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<byte> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, byte> getValue)
        {
            return values != null ? new list<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<byte> getList(this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new list<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<byte> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, byte> getValue)
        {
            return values != null ? new collection<byte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<byte> getCollection
            (this System.Collections.Generic.ICollection<byte> values)
        {
            return values != null ? new collection<byte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<byte> getFind
            (this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<byte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<byte> getFind
            (this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                byte[] newValues = new byte[values.Count];
                fixed (byte* newValueFixed = newValues)
                {
                    byte* write = newValueFixed;
                    foreach (byte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<byte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<byte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte[] getFindArray
            (this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte[] getFindArray
            (this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            if (values.count() != 0)
            {
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static sbyte[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, sbyte> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<sbyte>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<sbyte> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, sbyte> getValue)
        {
            return values != null ? new list<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<sbyte> getList(this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new list<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<sbyte> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, sbyte> getValue)
        {
            return values != null ? new collection<sbyte>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<sbyte> getCollection
            (this System.Collections.Generic.ICollection<sbyte> values)
        {
            return values != null ? new collection<sbyte>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<sbyte> getFind
            (this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<sbyte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<sbyte> getFind
            (this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                sbyte[] newValues = new sbyte[values.Count];
                fixed (sbyte* newValueFixed = newValues)
                {
                    sbyte* write = newValueFixed;
                    foreach (sbyte value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<sbyte>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<sbyte>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte[] getFindArray
            (this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte[] getFindArray
            (this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray
            (this System.Collections.Generic.ICollection<double> values)
        {
            if (values.count() != 0)
            {
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static double[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, double> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<double> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, double> getValue)
        {
            return values != null ? new list<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<double> getList(this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new list<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<double> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, double> getValue)
        {
            return values != null ? new collection<double>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<double> getCollection
            (this System.Collections.Generic.ICollection<double> values)
        {
            return values != null ? new collection<double>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<double> getFind
            (this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<double> getFind
            (this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                double[] newValues = new double[values.Count];
                fixed (double* newValueFixed = newValues)
                {
                    double* write = newValueFixed;
                    foreach (double value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<double>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getFindArray
            (this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getFindArray
            (this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray
            (this System.Collections.Generic.ICollection<float> values)
        {
            if (values.count() != 0)
            {
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static float[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, float> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<float> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, float> getValue)
        {
            return values != null ? new list<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<float> getList(this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new list<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<float> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, float> getValue)
        {
            return values != null ? new collection<float>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<float> getCollection
            (this System.Collections.Generic.ICollection<float> values)
        {
            return values != null ? new collection<float>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<float> getFind
            (this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<float> getFind
            (this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                float[] newValues = new float[values.Count];
                fixed (float* newValueFixed = newValues)
                {
                    float* write = newValueFixed;
                    foreach (float value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<float>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getFindArray
            (this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getFindArray
            (this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static partial class iCollection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            if (values.count() != 0)
            {
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values) *write++ = value;
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public unsafe static DateTime[] getArray<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, DateTime> getValue)
        {
            if (values.count() != 0)
            {
                if (getValue == null) log.Error.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (valueType value in values) *write++ = getValue(value);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<DateTime> getList<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, DateTime> getValue)
        {
            return values != null ? new list<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回单向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>单向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static list<DateTime> getList(this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new list<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<DateTime> getCollection<valueType>
            (this System.Collections.Generic.ICollection<valueType> values, Func<valueType, DateTime> getValue)
        {
            return values != null ? new collection<DateTime>(getArray(values, getValue), true) : null;
        }
        /// <summary>
        /// 根据集合内容返回双向列表
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>双向列表</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static collection<DateTime> getCollection
            (this System.Collections.Generic.ICollection<DateTime> values)
        {
            return values != null ? new collection<DateTime>(getArray(values), true) : null;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<DateTime> getFind
            (this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            if (values.count() != 0)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public unsafe static subArray<DateTime> getFind
            (this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            if (values != null)
            {
                if (isValue == null) log.Error.Throw(log.exceptionType.Null);
                DateTime[] newValues = new DateTime[values.Count];
                fixed (DateTime* newValueFixed = newValues)
                {
                    DateTime* write = newValueFixed;
                    foreach (DateTime value in values)
                    {
                        if (isValue(value)) *write++ = value;
                    }
                    return subArray<DateTime>.Unsafe(newValues, 0, (int)(write - newValueFixed));
                }
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime[] getFindArray
            (this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime[] getFindArray
            (this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray().notNull();
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long max
            (this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long min
            (this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , out long value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static long minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey
            , long nullValue)
        {
            long value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint max
            (this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint min
            (this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , out uint value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static uint minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey
            , uint nullValue)
        {
            uint value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int max
            (this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int min
            (this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , out int value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static int minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey
            , int nullValue)
        {
            int value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort max
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort min
            (this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , out ushort value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static ushort minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey
            , ushort nullValue)
        {
            ushort value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short max
            (this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short min
            (this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , out short value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static short minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey
            , short nullValue)
        {
            short value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte max
            (this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte min
            (this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , out byte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static byte minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey
            , byte nullValue)
        {
            byte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte max
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte min
            (this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , out sbyte value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static sbyte minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey
            , sbyte nullValue)
        {
            sbyte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double max
            (this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double min
            (this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , out double value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey
            , double nullValue)
        {
            double value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float max
            (this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float min
            (this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , out float value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey
            , float nullValue)
        {
            float value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class iEnumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime max
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType max<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime maxKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min
            (this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime min
            (this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType min<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , out DateTime value)
        {
            if (values != null)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static DateTime minKey<valueType>
            (this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey
            , DateTime nullValue)
        {
            DateTime value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (ulong* startIndex, ulong* endIndex)
        {
            do
            {
                ulong leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulong* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulong value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(ulong[] values)
        {
            if (values.Length > 1)
            {
                fixed (ulong* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc(ulong[] values)
        {
            if (values.Length != 0)
            {
                ulong[] newValue = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(ulong[] values, int startIndex, int count)
        {
            fixed (ulong* valueFixed = values)
            {
                ulong* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static ulong[] GetSortDesc
            (ulong[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                ulong[] newValues = new ulong[count];
                Buffer.BlockCopy(values, startIndex * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<ulong>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (ulongSortIndex* startIndex, ulongSortIndex* endIndex)
        {
            do
            {
                ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ulong value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(ulongSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(ulongSortIndex));
            try
            {
                return getSortDesc(values, getKey, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, ulongSortIndex* fixedIndex)
        {
            ulongSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return ulongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(ulongSortIndex));
            pointer.size data = pool.Get(count * sizeof(ulongSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int startIndex, int count
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return ulongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort(long[] values)
        {
            if (values.Length != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSort
            (long[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (longSortIndex* startIndex, longSortIndex* endIndex)
        {
            do
            {
                longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                longSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                longSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, long> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(longSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(longSortIndex));
            try
            {
                return getSort(values, getKey, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, long> getKey, longSortIndex* fixedIndex)
        {
            longSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return longSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, long> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(longSortIndex));
            pointer.size data = pool.Get(count * sizeof(longSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, long> getKey, int startIndex, int count
            , longSortIndex* fixedIndex)
        {
            longSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return longSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc(long[] values)
        {
            if (values.Length != 0)
            {
                long[] newValue = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static long[] GetSortDesc
            (long[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                long[] newValues = new long[count];
                Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<long>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (longSortIndex* startIndex, longSortIndex* endIndex)
        {
            do
            {
                longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                longSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                longSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(longSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(longSortIndex));
            try
            {
                return getSortDesc(values, getKey, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, longSortIndex* fixedIndex)
        {
            longSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return longSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(longSortIndex));
            pointer.size data = pool.Get(count * sizeof(longSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int startIndex, int count
            , longSortIndex* fixedIndex)
        {
            longSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return longSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort(uint[] values)
        {
            if (values.Length != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSort
            (uint[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (uintSortIndex* startIndex, uintSortIndex* endIndex)
        {
            do
            {
                uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uintSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(uintSortIndex));
            try
            {
                return getSort(values, getKey, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey, uintSortIndex* fixedIndex)
        {
            uintSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return uintSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(uintSortIndex));
            pointer.size data = pool.Get(count * sizeof(uintSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int startIndex, int count
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return uintSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc(uint[] values)
        {
            if (values.Length != 0)
            {
                uint[] newValue = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static uint[] GetSortDesc
            (uint[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                uint[] newValues = new uint[count];
                Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<uint>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (uintSortIndex* startIndex, uintSortIndex* endIndex)
        {
            do
            {
                uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uintSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uintSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(uintSortIndex));
            try
            {
                return getSortDesc(values, getKey, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, uintSortIndex* fixedIndex)
        {
            uintSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return uintSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(uintSortIndex));
            pointer.size data = pool.Get(count * sizeof(uintSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int startIndex, int count
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return uintSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort(int[] values)
        {
            if (values.Length != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSort
            (int[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (intSortIndex* startIndex, intSortIndex* endIndex)
        {
            do
            {
                intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                intSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                intSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, int> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(intSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(intSortIndex));
            try
            {
                return getSort(values, getKey, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, int> getKey, intSortIndex* fixedIndex)
        {
            intSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return intSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, int> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(intSortIndex));
            pointer.size data = pool.Get(count * sizeof(intSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, int> getKey, int startIndex, int count
            , intSortIndex* fixedIndex)
        {
            intSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return intSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc(int[] values)
        {
            if (values.Length != 0)
            {
                int[] newValue = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static int[] GetSortDesc
            (int[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                int[] newValues = new int[count];
                Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<int>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (intSortIndex* startIndex, intSortIndex* endIndex)
        {
            do
            {
                intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                intSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                intSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(intSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(intSortIndex));
            try
            {
                return getSortDesc(values, getKey, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, intSortIndex* fixedIndex)
        {
            intSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return intSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(intSortIndex));
            pointer.size data = pool.Get(count * sizeof(intSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int startIndex, int count
            , intSortIndex* fixedIndex)
        {
            intSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return intSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort(double[] values)
        {
            if (values.Length != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSort
            (double[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (doubleSortIndex* startIndex, doubleSortIndex* endIndex)
        {
            do
            {
                doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                doubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                doubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, double> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(doubleSortIndex));
            try
            {
                return getSort(values, getKey, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, double> getKey, doubleSortIndex* fixedIndex)
        {
            doubleSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return doubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, double> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(count * sizeof(doubleSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, double> getKey, int startIndex, int count
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return doubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc(double[] values)
        {
            if (values.Length != 0)
            {
                double[] newValue = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static double[] GetSortDesc
            (double[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                double[] newValues = new double[count];
                Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (doubleSortIndex* startIndex, doubleSortIndex* endIndex)
        {
            do
            {
                doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                doubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                doubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(doubleSortIndex));
            try
            {
                return getSortDesc(values, getKey, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, doubleSortIndex* fixedIndex)
        {
            doubleSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return doubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(count * sizeof(doubleSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int startIndex, int count
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return doubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort(float[] values)
        {
            if (values.Length != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSort
            (float[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (floatSortIndex* startIndex, floatSortIndex* endIndex)
        {
            do
            {
                floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                floatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                floatSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, float> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(floatSortIndex));
            try
            {
                return getSort(values, getKey, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, float> getKey, floatSortIndex* fixedIndex)
        {
            floatSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return floatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, float> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(floatSortIndex));
            pointer.size data = pool.Get(count * sizeof(floatSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, float> getKey, int startIndex, int count
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return floatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc(float[] values)
        {
            if (values.Length != 0)
            {
                float[] newValue = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static float[] GetSortDesc
            (float[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                float[] newValues = new float[count];
                Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (floatSortIndex* startIndex, floatSortIndex* endIndex)
        {
            do
            {
                floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                floatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                floatSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(floatSortIndex));
            try
            {
                return getSortDesc(values, getKey, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, floatSortIndex* fixedIndex)
        {
            floatSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return floatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(floatSortIndex));
            pointer.size data = pool.Get(count * sizeof(floatSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int startIndex, int count
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return floatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sort
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sort(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort(DateTime[] values)
        {
            if (values.Length != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void Sort(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSort
            (DateTime[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sort(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sort
            (dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
        {
            do
            {
                dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                dateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                dateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(dateTimeSortIndex));
            try
            {
                return getSort(values, getKey, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return dateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(count * sizeof(dateTimeSortIndex));
            try
            {
                return getSort(values, getKey, startIndex, count, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return dateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private unsafe static void sortDesc
            (DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values)
                {
                    sortDesc(valueFixed, valueFixed + values.Length - 1);
                }
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc(DateTime[] values)
        {
            if (values.Length != 0)
            {
                DateTime[] newValue = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValue, valueFixed = values)
                {
                    sortDesc(newValueFixed, newValueFixed + values.Length - 1);
                }
                return newValue;
            }
            return values;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public unsafe static void SortDesc(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public unsafe static DateTime[] GetSortDesc
            (DateTime[] values, int startIndex, int count)
        {
            if (count != 0)
            {
                DateTime[] newValues = new DateTime[count];
                Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
                }
                return newValues;
            }
            return nullValue<DateTime>.Array;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal unsafe static void sortDesc
            (dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
        {
            do
            {
                dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                dateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                dateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(values.Length * sizeof(dateTimeSortIndex));
            try
            {
                return getSortDesc(values, getKey, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return dateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count)
        {
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(count * sizeof(dateTimeSortIndex));
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return dateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] sortDesc(this double[] array)
        {
            if (array != null)
            {
                fastCSharp.algorithm.quickSort.SortDesc(array);
                return array;
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getSortDesc(this double[] array)
        {
            if (array != null)
            {
                return fastCSharp.algorithm.quickSort.GetSortDesc(array);
            }
            return nullValue<double>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSortDesc<valueType>
            (this valueType[] array, Func<valueType, double> getKey)
        {
            if (getKey == null) log.Error.Throw(log.exceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return fastCSharp.algorithm.quickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return nullValue<valueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> sortDesc(this subArray<double> array)
        {
            if (array.Count > 1) fastCSharp.algorithm.quickSort.SortDesc(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static double[] getSortDesc(this subArray<double> array)
        {
            return fastCSharp.algorithm.quickSort.GetSortDesc(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this subArray<valueType> array, Func<valueType, double> getKey)
        {
            if (array.Count > 1) return fastCSharp.algorithm.quickSort.GetSortDesc(array.UnsafeArray, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? nullValue<valueType>.Array : new valueType[] { array.UnsafeArray[array.StartIndex] };
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] sort(this float[] array)
        {
            if (array != null)
            {
                fastCSharp.algorithm.quickSort.Sort(array);
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getSort(this float[] array)
        {
            if (array != null)
            {
                return fastCSharp.algorithm.quickSort.GetSort(array);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSort<valueType>
            (this valueType[] array, Func<valueType, float> getKey)
        {
            if (getKey == null) log.Error.Throw(log.exceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return fastCSharp.algorithm.quickSort.GetSort(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return nullValue<valueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> sort(this subArray<float> array)
        {
            if (array.Count > 1) fastCSharp.algorithm.quickSort.Sort(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getSort(this subArray<float> array)
        {
            return fastCSharp.algorithm.quickSort.GetSort(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSort<valueType>(this subArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Count > 1) return fastCSharp.algorithm.quickSort.GetSort(array.UnsafeArray, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? nullValue<valueType>.Array : new valueType[] { array.UnsafeArray[array.StartIndex] };
        }
    }
}
namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] sortDesc(this float[] array)
        {
            if (array != null)
            {
                fastCSharp.algorithm.quickSort.SortDesc(array);
                return array;
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getSortDesc(this float[] array)
        {
            if (array != null)
            {
                return fastCSharp.algorithm.quickSort.GetSortDesc(array);
            }
            return nullValue<float>.Array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSortDesc<valueType>
            (this valueType[] array, Func<valueType, float> getKey)
        {
            if (getKey == null) log.Error.Throw(log.exceptionType.Null);
            if (array != null)
            {
                if (array.Length > 1) return fastCSharp.algorithm.quickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return nullValue<valueType>.Array;
        }
    }
    
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> sortDesc(this subArray<float> array)
        {
            if (array.Count > 1) fastCSharp.algorithm.quickSort.SortDesc(array.UnsafeArray, array.StartIndex, array.Count);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static float[] getSortDesc(this subArray<float> array)
        {
            return fastCSharp.algorithm.quickSort.GetSortDesc(array.UnsafeArray, array.StartIndex, array.Count);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this subArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Count > 1) return fastCSharp.algorithm.quickSort.GetSortDesc(array.UnsafeArray, getKey, array.StartIndex, array.Count);
            return array.Count == 0 ? nullValue<valueType>.Array : new valueType[] { array.UnsafeArray[array.StartIndex] };
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct ulongRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulong* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulong* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulong* startIndex, ulong* endIndex)
            {
                do
                {
                    ulong leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulong* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulong value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<ulong> RangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulong* valueFixed = values)
                {
                    new ulongRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<ulong>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<ulong> GetRangeSortDesc
            (ulong[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                ulong[] newValues = new ulong[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(ulong));
                fixed (ulong* newValueFixed = newValues, valueFixed = values)
                {
                    new ulongRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<ulong>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<ulong> RangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (ulong* valueFixed = values)
                    {
                        ulong* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new ulongRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<ulong>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<ulong> GetRangeSortDesc
            (ulong[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    ulong[] newValues = new ulong[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(ulong), newValues, 0, count * sizeof(ulong));
                    fixed (ulong* newValueFixed = newValues, valueFixed = values)
                    {
                        new ulongRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<ulong>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<ulong>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct ulongRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulongSortIndex* startIndex, ulongSortIndex* endIndex)
            {
                do
                {
                    ulongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ulong value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(ulongSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(ulongSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (ulongSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, ulongSortIndex* fixedIndex)
        {
            new ulongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            ulongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, ulongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (ulongSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(ulongSortIndex));
                    pointer.size data = pool.Get(count * sizeof(ulongSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (ulongSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount
            , ulongSortIndex* fixedIndex)
        {
            ulongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new ulongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> rangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> getRangeSortDesc
            (this ulong[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> rangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> getRangeSortDesc
            (this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> pageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> getPageSortDesc
            (this ulong[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, ulong> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> rangeSortDesc
            (this subArray<ulong> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<ulong> getRangeSortDesc
            (this subArray<ulong> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<ulong> pageSortDesc
            (this subArray<ulong> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<ulong> getPageSortDesc
            (this subArray<ulong> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<ulong>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct longRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> RangeSort
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<long>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<long> GetRangeSort
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<long>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> RangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<long>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<long> GetRangeSort
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<long>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<long>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct longRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public longSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public longSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(longSortIndex* startIndex, longSortIndex* endIndex)
            {
                do
                {
                    longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    longSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    longSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(longSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(longSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (longSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, longSortIndex* fixedIndex)
        {
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            longSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, longSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (longSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(longSortIndex));
                    pointer.size data = pool.Get(count * sizeof(longSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (longSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new longRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSort
            (this long[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSort
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> pageSort
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getPageSort
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSort
            (this subArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSort
            (this subArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<long> pageSort
            (this subArray<long> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<long> getPageSort
            (this subArray<long> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct longRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> RangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (long* valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<long>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<long> GetRangeSortDesc
            (long[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                long[] newValues = new long[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(long));
                fixed (long* newValueFixed = newValues, valueFixed = values)
                {
                    new longRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<long>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> RangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (long* valueFixed = values)
                    {
                        long* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new longRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<long>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<long> GetRangeSortDesc
            (long[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    long[] newValues = new long[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(long), newValues, 0, count * sizeof(long));
                    fixed (long* newValueFixed = newValues, valueFixed = values)
                    {
                        new longRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<long>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<long>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct longRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public longSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public longSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(longSortIndex* startIndex, longSortIndex* endIndex)
            {
                do
                {
                    longSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    longSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    longSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(longSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(longSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (longSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, longSortIndex* fixedIndex)
        {
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            longSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, longSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (longSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(longSortIndex));
                    pointer.size data = pool.Get(count * sizeof(longSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (longSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount
            , longSortIndex* fixedIndex)
        {
            longSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new longRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSortDesc
            (this long[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSortDesc
            (this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> pageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getPageSortDesc
            (this long[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> rangeSortDesc
            (this subArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<long> getRangeSortDesc
            (this subArray<long> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<long> pageSortDesc
            (this subArray<long> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<long> getPageSortDesc
            (this subArray<long> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<long>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct uintRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> RangeSort
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<uint>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<uint> GetRangeSort
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<uint>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> RangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<uint>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<uint> GetRangeSort
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<uint>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<uint>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct uintRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uintSortIndex* startIndex, uintSortIndex* endIndex)
            {
                do
                {
                    uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(uintSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(uintSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (uintSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, uintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            uintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, uintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uintSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(uintSortIndex));
                    pointer.size data = pool.Get(count * sizeof(uintSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (uintSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new uintRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSort
            (this uint[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSort
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> pageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getPageSort
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSort
            (this subArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSort
            (this subArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<uint> pageSort
            (this subArray<uint> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<uint> getPageSort
            (this subArray<uint> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct uintRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> RangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uint* valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<uint>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<uint> GetRangeSortDesc
            (uint[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                uint[] newValues = new uint[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(uint));
                fixed (uint* newValueFixed = newValues, valueFixed = values)
                {
                    new uintRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<uint>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> RangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (uint* valueFixed = values)
                    {
                        uint* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new uintRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<uint>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<uint> GetRangeSortDesc
            (uint[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    uint[] newValues = new uint[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(uint), newValues, 0, count * sizeof(uint));
                    fixed (uint* newValueFixed = newValues, valueFixed = values)
                    {
                        new uintRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<uint>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<uint>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct uintRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uintSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uintSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uintSortIndex* startIndex, uintSortIndex* endIndex)
            {
                do
                {
                    uintSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uintSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uintSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(uintSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(uintSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (uintSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, uintSortIndex* fixedIndex)
        {
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            uintSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, uintSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (uintSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(uintSortIndex));
                    pointer.size data = pool.Get(count * sizeof(uintSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (uintSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount
            , uintSortIndex* fixedIndex)
        {
            uintSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new uintRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSortDesc
            (this uint[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSortDesc
            (this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> pageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getPageSortDesc
            (this uint[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> rangeSortDesc
            (this subArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<uint> getRangeSortDesc
            (this subArray<uint> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<uint> pageSortDesc
            (this subArray<uint> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<uint> getPageSortDesc
            (this subArray<uint> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<uint>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct intRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> RangeSort
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<int>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<int> GetRangeSort
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<int>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> RangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<int>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<int> GetRangeSort
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<int>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<int>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct intRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public intSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public intSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(intSortIndex* startIndex, intSortIndex* endIndex)
            {
                do
                {
                    intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    intSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    intSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(intSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(intSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (intSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, intSortIndex* fixedIndex)
        {
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            intSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, intSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (intSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(intSortIndex));
                    pointer.size data = pool.Get(count * sizeof(intSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (intSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new intRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSort
            (this int[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSort
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> pageSort
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getPageSort
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSort
            (this subArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSort
            (this subArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<int> pageSort
            (this subArray<int> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<int> getPageSort
            (this subArray<int> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct intRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> RangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (int* valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<int>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<int> GetRangeSortDesc
            (int[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                int[] newValues = new int[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(int));
                fixed (int* newValueFixed = newValues, valueFixed = values)
                {
                    new intRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<int>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> RangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (int* valueFixed = values)
                    {
                        int* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new intRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<int>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<int> GetRangeSortDesc
            (int[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    int[] newValues = new int[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(int), newValues, 0, count * sizeof(int));
                    fixed (int* newValueFixed = newValues, valueFixed = values)
                    {
                        new intRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<int>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<int>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct intRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public intSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public intSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(intSortIndex* startIndex, intSortIndex* endIndex)
            {
                do
                {
                    intSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    intSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    intSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(intSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(intSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (intSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, intSortIndex* fixedIndex)
        {
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            intSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, intSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (intSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(intSortIndex));
                    pointer.size data = pool.Get(count * sizeof(intSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (intSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount
            , intSortIndex* fixedIndex)
        {
            intSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new intRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSortDesc
            (this int[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSortDesc
            (this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> pageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getPageSortDesc
            (this int[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> rangeSortDesc
            (this subArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<int> getRangeSortDesc
            (this subArray<int> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<int> pageSortDesc
            (this subArray<int> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<int> getPageSortDesc
            (this subArray<int> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<int>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct doubleRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> RangeSort
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<double>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<double> GetRangeSort
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<double>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> RangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<double>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<double> GetRangeSort
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<double>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<double>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct doubleRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public doubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public doubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(doubleSortIndex* startIndex, doubleSortIndex* endIndex)
            {
                do
                {
                    doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    doubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    doubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(doubleSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(doubleSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (doubleSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, doubleSortIndex* fixedIndex)
        {
            new doubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            doubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, doubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (doubleSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(doubleSortIndex));
                    pointer.size data = pool.Get(count * sizeof(doubleSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (doubleSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new doubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSort
            (this double[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSort
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> pageSort
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getPageSort
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSort
            (this subArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSort
            (this subArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<double> pageSort
            (this subArray<double> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<double> getPageSort
            (this subArray<double> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct doubleRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> RangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (double* valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<double>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<double> GetRangeSortDesc
            (double[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                double[] newValues = new double[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(double));
                fixed (double* newValueFixed = newValues, valueFixed = values)
                {
                    new doubleRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<double>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> RangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (double* valueFixed = values)
                    {
                        double* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new doubleRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<double>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<double> GetRangeSortDesc
            (double[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    double[] newValues = new double[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(double), newValues, 0, count * sizeof(double));
                    fixed (double* newValueFixed = newValues, valueFixed = values)
                    {
                        new doubleRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<double>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<double>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct doubleRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public doubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public doubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(doubleSortIndex* startIndex, doubleSortIndex* endIndex)
            {
                do
                {
                    doubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    doubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    doubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(doubleSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(doubleSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (doubleSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, doubleSortIndex* fixedIndex)
        {
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            doubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, doubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (doubleSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(doubleSortIndex));
                    pointer.size data = pool.Get(count * sizeof(doubleSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (doubleSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount
            , doubleSortIndex* fixedIndex)
        {
            doubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new doubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSortDesc
            (this double[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSortDesc
            (this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> pageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getPageSortDesc
            (this double[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> rangeSortDesc
            (this subArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<double> getRangeSortDesc
            (this subArray<double> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<double> pageSortDesc
            (this subArray<double> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<double> getPageSortDesc
            (this subArray<double> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<double>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct floatRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> RangeSort
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<float>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<float> GetRangeSort
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<float>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> RangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<float>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<float> GetRangeSort
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<float>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<float>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct floatRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public floatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public floatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(floatSortIndex* startIndex, floatSortIndex* endIndex)
            {
                do
                {
                    floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    floatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    floatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(floatSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(floatSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (floatSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, floatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            floatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, floatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (floatSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(floatSortIndex));
                    pointer.size data = pool.Get(count * sizeof(floatSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (floatSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new floatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSort
            (this float[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSort
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> pageSort
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getPageSort
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSort
            (this subArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSort
            (this subArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<float> pageSort
            (this subArray<float> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<float> getPageSort
            (this subArray<float> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct floatRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> RangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (float* valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<float>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<float> GetRangeSortDesc
            (float[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                float[] newValues = new float[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(float));
                fixed (float* newValueFixed = newValues, valueFixed = values)
                {
                    new floatRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<float>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> RangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (float* valueFixed = values)
                    {
                        float* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new floatRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<float>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<float> GetRangeSortDesc
            (float[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    float[] newValues = new float[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(float), newValues, 0, count * sizeof(float));
                    fixed (float* newValueFixed = newValues, valueFixed = values)
                    {
                        new floatRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<float>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<float>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct floatRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public floatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public floatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(floatSortIndex* startIndex, floatSortIndex* endIndex)
            {
                do
                {
                    floatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    floatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    floatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(floatSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(floatSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (floatSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, floatSortIndex* fixedIndex)
        {
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            floatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, floatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (floatSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(floatSortIndex));
                    pointer.size data = pool.Get(count * sizeof(floatSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (floatSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount
            , floatSortIndex* fixedIndex)
        {
            floatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new floatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSortDesc
            (this float[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSortDesc
            (this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> pageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getPageSortDesc
            (this float[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> rangeSortDesc
            (this subArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<float> getRangeSortDesc
            (this subArray<float> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<float> pageSortDesc
            (this subArray<float> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<float> getPageSortDesc
            (this subArray<float> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<float>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct dateTimeRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> RangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new dateTimeRangeSorter
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<DateTime>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<DateTime> GetRangeSort
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new dateTimeRangeSorter
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<DateTime>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> RangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new dateTimeRangeSorter
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<DateTime>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<DateTime> GetRangeSort
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new dateTimeRangeSorter
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<DateTime>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<DateTime>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct dateTimeRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public dateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public dateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
            {
                do
                {
                    dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    dateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    dateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(dateTimeSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(dateTimeSortIndex));
                try
                {
                    return getRangeSort(values, getKey, range.SkipCount, getCount, (dateTimeSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSort(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int skipCount, int getCount, dateTimeSortIndex* fixedIndex)
        {
            new dateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            dateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, dateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (dateTimeSortIndex* fixedIndex = indexs) return getRangeSort(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(dateTimeSortIndex));
                    pointer.size data = pool.Get(count * sizeof(dateTimeSortIndex));
                    try
                    {
                        return getRangeSort
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (dateTimeSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSort<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new dateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSort
            (this DateTime[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSort
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> pageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getPageSort
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSort<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSort
            (this subArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSort
            (this subArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSort<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<DateTime> pageSort
            (this subArray<DateTime> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<DateTime> getPageSort
            (this subArray<DateTime> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSort(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        internal unsafe struct dateTimeRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> RangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (DateTime* valueFixed = values)
                {
                    new dateTimeRangeSorterDesc
                    {
                        SkipCount = valueFixed + range.SkipCount,
                        GetEndIndex = valueFixed + range.EndIndex - 1
                    }.Sort(valueFixed, valueFixed + values.Length - 1);
                }
                return subArray<DateTime>.Unsafe(values, range.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<DateTime> GetRangeSortDesc
            (DateTime[] values, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                DateTime[] newValues = new DateTime[values.Length];
                Buffer.BlockCopy(values, 0, newValues, 0, values.Length * sizeof(DateTime));
                fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                {
                    new dateTimeRangeSorterDesc
                    {
                        SkipCount = newValueFixed + range.SkipCount,
                        GetEndIndex = newValueFixed + range.EndIndex - 1
                    }.Sort(newValueFixed, newValueFixed + values.Length - 1);
                }
                return subArray<DateTime>.Unsafe(newValues, range.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> RangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    skipCount = range.SkipCount + getRange.SkipCount;
                    fixed (DateTime* valueFixed = values)
                    {
                        DateTime* skip = valueFixed + skipCount, start = valueFixed + range.SkipCount;
                        new dateTimeRangeSorterDesc
                        {
                            SkipCount = skip,
                            GetEndIndex = skip + getCount - 1
                        }.Sort(start, start + --count);
                    }
                    return subArray<DateTime>.Unsafe(values, skipCount, getCount);
                }
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        public unsafe static subArray<DateTime> GetRangeSortDesc
            (DateTime[] values, int startIndex, int count, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    DateTime[] newValues = new DateTime[count];
                    Buffer.BlockCopy(values, range.SkipCount * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
                    fixed (DateTime* newValueFixed = newValues, valueFixed = values)
                    {
                        new dateTimeRangeSorterDesc
                        {
                            SkipCount = newValueFixed + getRange.SkipCount,
                            GetEndIndex = newValueFixed + getRange.SkipCount + getCount - 1
                        }.Sort(newValueFixed, newValueFixed + count - 1);
                    }
                    return subArray<DateTime>.Unsafe(newValues, getRange.SkipCount, getCount);
                }
            }
            return default(subArray<DateTime>);
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        internal unsafe struct dateTimeRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public dateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public dateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(dateTimeSortIndex* startIndex, dateTimeSortIndex* endIndex)
            {
                do
                {
                    dateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    dateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    dateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(values.Length * sizeof(dateTimeSortIndex));
                pointer.size data = pool.Get(values.Length * sizeof(dateTimeSortIndex));
                try
                {
                    return getRangeSortDesc(values, getKey, range.SkipCount, getCount, (dateTimeSortIndex*)data.Data);
                }
                finally { pool.Push(ref data); }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != values.Length; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int skipCount, int getCount, dateTimeSortIndex* fixedIndex)
        {
            new dateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + values.Length - 1);
            valueType[] newValues = new valueType[getCount];
            dateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, dateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (values.length() != indexs.length()) log.Error.Throw(log.exceptionType.IndexOutOfRange);
            array.range range = new array.range(values.length(), skipCount, getCount);
            if ((getCount = range.GetCount) != 0)
            {
                fixed (dateTimeSortIndex* fixedIndex = indexs) return getRangeSortDesc(values, skipCount, getCount, fixedIndex);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public unsafe static valueType[] GetRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            array.range range = new array.range(values.length(), startIndex, count);
            if ((count = range.GetCount) != 0)
            {
                array.range getRange = new array.range(count, skipCount, getCount);
                if ((getCount = getRange.GetCount) != 0)
                {
                    if (getKey == null) log.Error.Throw(log.exceptionType.Null);
                    unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(count * sizeof(dateTimeSortIndex));
                    pointer.size data = pool.Get(count * sizeof(dateTimeSortIndex));
                    try
                    {
                        return getRangeSortDesc
                            (values, range.SkipCount, count, getKey, getRange.SkipCount, getCount, (dateTimeSortIndex*)data.Data);
                    }
                    finally { pool.Push(ref data); }
                }
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private unsafe static valueType[] getRangeSortDesc<valueType>
            (valueType[] values, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount
            , dateTimeSortIndex* fixedIndex)
        {
            dateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(values[index]), index++)) ;
            new dateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
    }
}

namespace fastCSharp
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static partial class arrayExtension
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSortDesc
            (this DateTime[] array, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSortDesc
            (this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> pageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.RangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getPageSortDesc
            (this DateTime[] array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.length(), pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }

    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static partial class subArrayExtension
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            array.page page = new array.page(count = array.Count, pageSize, currentPage);
            return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> rangeSortDesc
            (this subArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static subArray<DateTime> getRangeSortDesc
            (this subArray<DateTime> array, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, skipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>
            (this subArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (array.Count != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc
                    (array.UnsafeArray, array.StartIndex, array.Count, getKey, skipCount, getCount);
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<DateTime> pageSortDesc
            (this subArray<DateTime> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int count = page.CurrentPageSize;
            if (count != 0)
            {
                return fastCSharp.algorithm.quickSort.RangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, count);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        public static subArray<DateTime> getPageSortDesc
            (this subArray<DateTime> array, int pageSize, int currentPage)
        {
            array.page page = new array.page(array.Count, pageSize, currentPage);
            int getCount = page.CurrentPageSize;
            if (getCount != 0)
            {
                return fastCSharp.algorithm.quickSort.GetRangeSortDesc(array.UnsafeArray, array.StartIndex, array.Count, page.SkipCount, getCount);
            }
            return default(subArray<DateTime>);
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct longSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public long Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(long))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public void Set(long value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        internal unsafe static void Create<valueType>(longSortIndex* indexFixed, valueType[] values, Func<valueType, long> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        internal unsafe static void Create<valueType>(longSortIndex* indexFixed, valueType[] values, Func<valueType, long> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal unsafe static valueType[] Create<valueType>(longSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct uintSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public uint Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(uint))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public void Set(uint value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        internal unsafe static void Create<valueType>(uintSortIndex* indexFixed, valueType[] values, Func<valueType, uint> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        internal unsafe static void Create<valueType>(uintSortIndex* indexFixed, valueType[] values, Func<valueType, uint> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal unsafe static valueType[] Create<valueType>(uintSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct intSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public int Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(int))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public void Set(int value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        internal unsafe static void Create<valueType>(intSortIndex* indexFixed, valueType[] values, Func<valueType, int> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        internal unsafe static void Create<valueType>(intSortIndex* indexFixed, valueType[] values, Func<valueType, int> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal unsafe static valueType[] Create<valueType>(intSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct doubleSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public double Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(double))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public void Set(double value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        internal unsafe static void Create<valueType>(doubleSortIndex* indexFixed, valueType[] values, Func<valueType, double> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        internal unsafe static void Create<valueType>(doubleSortIndex* indexFixed, valueType[] values, Func<valueType, double> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal unsafe static valueType[] Create<valueType>(doubleSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    public struct floatSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public float Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(float))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
        public void Set(float value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        internal unsafe static void Create<valueType>(floatSortIndex* indexFixed, valueType[] values, Func<valueType, float> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        internal unsafe static void Create<valueType>(floatSortIndex* indexFixed, valueType[] values, Func<valueType, float> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal unsafe static valueType[] Create<valueType>(floatSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<ulong> GetTopDesc(ulong[] values, int count)
        {
            if (values == null) return default(subArray<ulong>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    ulong[] newValues = new ulong[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<ulong>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<ulong> TopDesc(ulong[] values, int count)
        {
            if (values == null) return default(subArray<ulong>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<ulong>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<ulong>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<ulong> getTopDesc(ulong[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] newValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, valueFixed = values)
            {
                ulong* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(ulong));
                ulong* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                ulongRangeSorterDesc sort
                    = new ulongRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (ulong maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<ulong>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static ulong[] getRemoveTopDesc
            (ulong[] values, int count)
        {
            ulong[] newValues = new ulong[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] removeValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ulong);
                ulong* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(ulong));
                ulong* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                ulongRangeSorterDesc sort
                    = new ulongRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (ulong maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ulong));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(ulongSortIndex));
            pointer.size data = pool.Get(length * sizeof(ulongSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count, int length
            , ulongSortIndex* indexFixed)
        {
            ulongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            ulongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            ulongRangeIndexSorterDesc sort
                = new ulongRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (ulong maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(ulongSortIndex));
            pointer.size data = pool.Get(length * sizeof(ulongSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (ulongSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, ulong> getKey, int count, valueType[] newValues, int length
            , ulongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ulongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            ulongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            ulongRangeIndexSorterDesc sort
                = new ulongRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ulong maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> GetTop(long[] values, int count)
        {
            if (values == null) return default(subArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    long[] newValues = new long[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> Top(long[] values, int count)
        {
            if (values == null) return default(subArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<long> getTop(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<long>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static long[] getRemoveTop
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorter sort
                    = new longRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(longSortIndex));
            pointer.size data = pool.Get(length * sizeof(longSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count, int length
            , longSortIndex* indexFixed)
        {
            longSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            longSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(longSortIndex));
            pointer.size data = pool.Get(length * sizeof(longSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count, valueType[] newValues, int length
            , longSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            longSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            longSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorter sort
                = new longRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> GetTopDesc(long[] values, int count)
        {
            if (values == null) return default(subArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    long[] newValues = new long[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<long> TopDesc(long[] values, int count)
        {
            if (values == null) return default(subArray<long>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<long>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<long>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<long> getTopDesc(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<long>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static long[] getRemoveTopDesc
            (long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                longRangeSorterDesc sort
                    = new longRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(longSortIndex));
            pointer.size data = pool.Get(length * sizeof(longSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count, int length
            , longSortIndex* indexFixed)
        {
            longSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            longSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(longSortIndex));
            pointer.size data = pool.Get(length * sizeof(longSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (longSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, long> getKey, int count, valueType[] newValues, int length
            , longSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            longSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            longSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            longRangeIndexSorterDesc sort
                = new longRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> GetTop(uint[] values, int count)
        {
            if (values == null) return default(subArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    uint[] newValues = new uint[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> Top(uint[] values, int count)
        {
            if (values == null) return default(subArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<uint> getTop(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<uint>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static uint[] getRemoveTop
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorter sort
                    = new uintRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(length * sizeof(uintSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count, int length
            , uintSortIndex* indexFixed)
        {
            uintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            uintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(length * sizeof(uintSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count, valueType[] newValues, int length
            , uintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            uintSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            uintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorter sort
                = new uintRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> GetTopDesc(uint[] values, int count)
        {
            if (values == null) return default(subArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    uint[] newValues = new uint[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<uint> TopDesc(uint[] values, int count)
        {
            if (values == null) return default(subArray<uint>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<uint>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<uint>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<uint> getTopDesc(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<uint>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static uint[] getRemoveTopDesc
            (uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                uintRangeSorterDesc sort
                    = new uintRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(length * sizeof(uintSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count, int length
            , uintSortIndex* indexFixed)
        {
            uintSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            uintSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(uintSortIndex));
            pointer.size data = pool.Get(length * sizeof(uintSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (uintSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, uint> getKey, int count, valueType[] newValues, int length
            , uintSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            uintSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            uintSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            uintRangeIndexSorterDesc sort
                = new uintRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> GetTop(int[] values, int count)
        {
            if (values == null) return default(subArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    int[] newValues = new int[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> Top(int[] values, int count)
        {
            if (values == null) return default(subArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<int> getTop(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<int>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static int[] getRemoveTop
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorter sort
                    = new intRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(intSortIndex));
            pointer.size data = pool.Get(length * sizeof(intSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count, int length
            , intSortIndex* indexFixed)
        {
            intSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            intSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(intSortIndex));
            pointer.size data = pool.Get(length * sizeof(intSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count, valueType[] newValues, int length
            , intSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            intSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            intSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorter sort
                = new intRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> GetTopDesc(int[] values, int count)
        {
            if (values == null) return default(subArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    int[] newValues = new int[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<int> TopDesc(int[] values, int count)
        {
            if (values == null) return default(subArray<int>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<int>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<int>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<int> getTopDesc(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<int>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static int[] getRemoveTopDesc
            (int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                intRangeSorterDesc sort
                    = new intRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(intSortIndex));
            pointer.size data = pool.Get(length * sizeof(intSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count, int length
            , intSortIndex* indexFixed)
        {
            intSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            intSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(intSortIndex));
            pointer.size data = pool.Get(length * sizeof(intSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (intSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, int> getKey, int count, valueType[] newValues, int length
            , intSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            intSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            intSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            intRangeIndexSorterDesc sort
                = new intRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> GetTop(double[] values, int count)
        {
            if (values == null) return default(subArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    double[] newValues = new double[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> Top(double[] values, int count)
        {
            if (values == null) return default(subArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<double> getTop(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<double>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static double[] getRemoveTop
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorter sort
                    = new doubleRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(length * sizeof(doubleSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count, int length
            , doubleSortIndex* indexFixed)
        {
            doubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            doubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            doubleRangeIndexSorter sort
                = new doubleRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(length * sizeof(doubleSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count, valueType[] newValues, int length
            , doubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            doubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            doubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            doubleRangeIndexSorter sort
                = new doubleRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> GetTopDesc(double[] values, int count)
        {
            if (values == null) return default(subArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    double[] newValues = new double[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<double> TopDesc(double[] values, int count)
        {
            if (values == null) return default(subArray<double>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<double>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<double>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<double> getTopDesc(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<double>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static double[] getRemoveTopDesc
            (double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                doubleRangeSorterDesc sort
                    = new doubleRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(length * sizeof(doubleSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count, int length
            , doubleSortIndex* indexFixed)
        {
            doubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            doubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(doubleSortIndex));
            pointer.size data = pool.Get(length * sizeof(doubleSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (doubleSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, double> getKey, int count, valueType[] newValues, int length
            , doubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            doubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            doubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            doubleRangeIndexSorterDesc sort
                = new doubleRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> GetTop(float[] values, int count)
        {
            if (values == null) return default(subArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    float[] newValues = new float[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> Top(float[] values, int count)
        {
            if (values == null) return default(subArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<float> getTop(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<float>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static float[] getRemoveTop
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorter sort
                    = new floatRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(length * sizeof(floatSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count, int length
            , floatSortIndex* indexFixed)
        {
            floatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            floatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(length * sizeof(floatSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count, valueType[] newValues, int length
            , floatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            floatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            floatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorter sort
                = new floatRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> GetTopDesc(float[] values, int count)
        {
            if (values == null) return default(subArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    float[] newValues = new float[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<float> TopDesc(float[] values, int count)
        {
            if (values == null) return default(subArray<float>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<float>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<float>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<float> getTopDesc(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<float>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static float[] getRemoveTopDesc
            (float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                floatRangeSorterDesc sort
                    = new floatRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(length * sizeof(floatSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count, int length
            , floatSortIndex* indexFixed)
        {
            floatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            floatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(floatSortIndex));
            pointer.size data = pool.Get(length * sizeof(floatSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (floatSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, float> getKey, int count, valueType[] newValues, int length
            , floatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            floatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            floatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            floatRangeIndexSorterDesc sort
                = new floatRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> GetTop(DateTime[] values, int count)
        {
            if (values == null) return default(subArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                else
                {
                    DateTime[] newValues = new DateTime[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> Top(DateTime[] values, int count)
        {
            if (values == null) return default(subArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTop(values, count);
                    values = getRemoveTop(values, count);
                }
                return subArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<DateTime> getTop(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                dateTimeRangeSorter sort
                    = new dateTimeRangeSorter
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<DateTime>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static DateTime[] getRemoveTop
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                dateTimeRangeSorter sort
                    = new dateTimeRangeSorter
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTop<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] Top<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTop(values, getKey, count);
                    else return getRemoveTop(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(length * sizeof(dateTimeSortIndex));
            try
            {
                return getTop(values, getKey, count, length, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTop<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count, int length
            , dateTimeSortIndex* indexFixed)
        {
            dateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            dateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            dateTimeRangeIndexSorter sort
                = new dateTimeRangeIndexSorter
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTop<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(length * sizeof(dateTimeSortIndex));
            try
            {
                removeTop(values, getKey, count, newValues, length, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTop<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count, valueType[] newValues, int length
            , dateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            dateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            dateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            dateTimeRangeIndexSorter sort
                = new dateTimeRangeIndexSorter
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}
namespace fastCSharp.algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static partial class quickSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> GetTopDesc(DateTime[] values, int count)
        {
            if (values == null) return default(subArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                else
                {
                    DateTime[] newValues = new DateTime[values.Length];
                    Array.Copy(values, 0, newValues, 0, values.Length);
                    values = newValues;
                }
                return subArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public unsafe static subArray<DateTime> TopDesc(DateTime[] values, int count)
        {
            if (values == null) return default(subArray<DateTime>);
            if (count > 0)
            {
                if (count < values.Length)
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, count);
                    values = getRemoveTopDesc(values, count);
                }
                return subArray<DateTime>.Unsafe(values, 0, values.Length);
            }
            return default(subArray<DateTime>);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static subArray<DateTime> getTopDesc(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                dateTimeRangeSorterDesc sort
                    = new dateTimeRangeSorterDesc
                    {
                        SkipCount = writeStat - 1, 
                        GetEndIndex = writeStat - 1
                    };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return subArray<DateTime>.Unsafe(newValues, 0, count);
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static DateTime[] getRemoveTopDesc
            (DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                dateTimeRangeSorterDesc sort
                    = new dateTimeRangeSorterDesc
                    {
                        SkipCount = removeStart,
                        GetEndIndex = removeStart
                    };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] GetTopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.copy();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static valueType[] TopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (count > 0)
            {
                if (count < values.length())
                {
                    if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
                    else return getRemoveTopDesc(values, getKey, count);
                }
                return values.notNull();
            }
            return nullValue<valueType>.Array;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(length * sizeof(dateTimeSortIndex));
            try
            {
                return getTopDesc(values, getKey, count, length, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getTopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count, int length
            , dateTimeSortIndex* indexFixed)
        {
            dateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            dateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            dateTimeRangeIndexSorterDesc sort
                = new dateTimeRangeIndexSorterDesc
                {
                    SkipCount = writeStat - 1,
                    GetEndIndex = writeStat - 1
                };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index)
            {
                newValues[index] = values[(*writeIndex++).Index];
            }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private unsafe static valueType[] getRemoveTopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            unmanagedPool pool = fastCSharp.unmanagedPool.GetDefaultPool(length * sizeof(dateTimeSortIndex));
            pointer.size data = pool.Get(length * sizeof(dateTimeSortIndex));
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (dateTimeSortIndex*)data.Data);
            }
            finally { pool.Push(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private unsafe static void removeTopDesc<valueType>
            (valueType[] values, Func<valueType, DateTime> getKey, int count, valueType[] newValues, int length
            , dateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            dateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            dateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            dateTimeRangeIndexSorterDesc sort
                = new dateTimeRangeIndexSorterDesc
                {
                    SkipCount = removeStart, 
                    GetEndIndex = removeStart
                };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}namespace fastCSharp.net.tcp
{
        public partial class deployServer : fastCSharp.code.cSharp.tcpServer.ICommandServer
        {

            /// <summary>
            /// deploy TCP服务
            /// </summary>
            public sealed class tcpServer : fastCSharp.net.tcp.commandServer
            {
                private readonly fastCSharp.net.tcp.deployServer _value_;
                /// <summary>
                /// deploy TCP调用服务端
                /// </summary>
                /// <param name="attribute">TCP调用服务器端配置信息</param>
                /// <param name="value">TCP服务目标对象</param>
                public tcpServer(fastCSharp.code.cSharp.tcpServer attribute = null, fastCSharp.net.tcp.deployServer value = null)
                    : base(attribute ?? fastCSharp.code.cSharp.tcpServer.GetConfig("deploy", typeof(fastCSharp.net.tcp.deployServer)))
                {
                    _value_ = value ?? new fastCSharp.net.tcp.deployServer();
                    setCommands(11);
                    identityOnCommands[0 + 128].Set(0 + 128, 0);
                    identityOnCommands[1 + 128].Set(1 + 128, 0);
                    identityOnCommands[2 + 128].Set(2 + 128);
                    identityOnCommands[3 + 128].Set(3 + 128);
                    identityOnCommands[4 + 128].Set(4 + 128);
                    identityOnCommands[5 + 128].Set(5 + 128);
                    identityOnCommands[6 + 128].Set(6 + 128);
                    identityOnCommands[7 + 128].Set(7 + 128);
                    identityOnCommands[8 + 128].Set(8 + 128);
                    identityOnCommands[9 + 128].Set(9 + 128);
                    identityOnCommands[verifyCommandIdentity = 10 + 128].Set(10 + 128, 1024);
                    _value_.SetCommandServer(this);
                }
                /// <summary>
                /// 命令处理
                /// </summary>
                /// <param name="index"></param>
                /// <param name="socket"></param>
                /// <param name="data"></param>
                protected override void doCommand(int index, socket socket, ref subArray<byte> data)
                {
                    if (index < 128) base.doCommand(index, socket, ref data);
                    else
                    {
                        switch (index - 128)
                        {
                            case 0: _M0(socket, ref data); return;
                            case 1: _M1(socket, ref data); return;
                            case 2: _M2(socket, ref data); return;
                            case 3: _M3(socket, ref data); return;
                            case 4: _M4(socket, ref data); return;
                            case 5: _M5(socket, ref data); return;
                            case 6: _M6(socket, ref data); return;
                            case 7: _M7(socket, ref data); return;
                            case 8: _M8(socket, ref data); return;
                            case 9: _M9(socket, ref data); return;
                            case 10: _M10(socket, ref data); return;
                            default: return;
                        }
                    }
                }

                sealed class _s0 : fastCSharp.net.tcp.commandServer.serverCall<_s0, fastCSharp.net.tcp.deployServer>
                {
                    private void get(ref fastCSharp.net.returnValue value)
                    {
                        try
                        {
                            


                            serverValue.clear();

                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue value = new fastCSharp.net.returnValue();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s0>.PushNotNull(this);
                    }
                }
                private void _M0(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            {
                                fastCSharp.threading.task.Tiny.Add(_s0/**/.GetCall(socket, _value_ ));
                                return;
                            }
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o1 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o1 : fastCSharp.net.asynchronousMethod.IReturnParameter<fastCSharp.net.indexIdentity>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public fastCSharp.net.indexIdentity Ret;
                    public fastCSharp.net.indexIdentity Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (fastCSharp.net.indexIdentity)value; }
                    }
#endif
                }
                sealed class _s1 : fastCSharp.net.tcp.commandServer.serverCall<_s1, fastCSharp.net.tcp.deployServer>
                {
                    private void get(ref fastCSharp.net.returnValue<_o1> value)
                    {
                        try
                        {
                            
                            fastCSharp.net.indexIdentity Return;


                            
                            Return = serverValue.create();

                            value.Value = new _o1
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o1> value = new fastCSharp.net.returnValue<_o1>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s1>.PushNotNull(this);
                    }
                }
                private void _M1(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            {
                                fastCSharp.threading.task.Tiny.Add(_s1/**/.GetCall(socket, _value_ ));
                                return;
                            }
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i2
                {
                    public fastCSharp.net.indexIdentity identity;
                }
                sealed class _s2 : fastCSharp.net.tcp.commandServer.serverCall<_s2, fastCSharp.net.tcp.deployServer, _i2>
                {
                    private void get(ref fastCSharp.net.returnValue value)
                    {
                        try
                        {
                            


                            serverValue.clear(inputParameter.identity);

                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue value = new fastCSharp.net.returnValue();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s2>.PushNotNull(this);
                    }
                }
                private void _M2(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i2 inputParameter = new _i2();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                fastCSharp.threading.task.Tiny.Add(_s2/**/.GetCall(socket, _value_, ref inputParameter ));
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i3
                {
                    public fastCSharp.net.indexIdentity identity;
                    public System.DateTime time;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o3 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o3 : fastCSharp.net.asynchronousMethod.IReturnParameter<bool>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public bool Ret;
                    public bool Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (bool)value; }
                    }
#endif
                }
                sealed class _s3 : fastCSharp.net.tcp.commandServer.serverCall<_s3, fastCSharp.net.tcp.deployServer, _i3>
                {
                    private void get(ref fastCSharp.net.returnValue<_o3> value)
                    {
                        try
                        {
                            
                            bool Return;


                            
                            Return = serverValue.start(inputParameter.identity, inputParameter.time);

                            value.Value = new _o3
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o3> value = new fastCSharp.net.returnValue<_o3>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s3>.PushNotNull(this);
                    }
                }
                private void _M3(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i3 inputParameter = new _i3();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                _s3/**/.Call(socket, _value_, ref inputParameter );
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i4
                {
                    public fastCSharp.net.indexIdentity identity;
                    public byte[][] files;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o4 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o4 : fastCSharp.net.asynchronousMethod.IReturnParameter<bool>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public bool Ret;
                    public bool Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (bool)value; }
                    }
#endif
                }
                sealed class _s4 : fastCSharp.net.tcp.commandServer.serverCall<_s4, fastCSharp.net.tcp.deployServer, _i4>
                {
                    private void get(ref fastCSharp.net.returnValue<_o4> value)
                    {
                        try
                        {
                            
                            bool Return;


                            
                            Return = serverValue.setFileSource(inputParameter.identity, inputParameter.files);

                            value.Value = new _o4
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o4> value = new fastCSharp.net.returnValue<_o4>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s4>.PushNotNull(this);
                    }
                }
                private void _M4(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i4 inputParameter = new _i4();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                fastCSharp.threading.task.Tiny.Add(_s4/**/.GetCall(socket, _value_, ref inputParameter ));
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i5
                {
                    public fastCSharp.net.tcp.deployServer.directory directory;
                    public string serverPath;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o5 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o5 : fastCSharp.net.asynchronousMethod.IReturnParameter<fastCSharp.net.tcp.deployServer.directory>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public fastCSharp.net.tcp.deployServer.directory Ret;
                    public fastCSharp.net.tcp.deployServer.directory Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (fastCSharp.net.tcp.deployServer.directory)value; }
                    }
#endif
                }
                sealed class _s5 : fastCSharp.net.tcp.commandServer.serverCall<_s5, fastCSharp.net.tcp.deployServer, _i5>
                {
                    private void get(ref fastCSharp.net.returnValue<_o5> value)
                    {
                        try
                        {
                            
                            fastCSharp.net.tcp.deployServer.directory Return;


                            
                            Return = serverValue.getFileDifferent(inputParameter.directory, inputParameter.serverPath);

                            value.Value = new _o5
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o5> value = new fastCSharp.net.returnValue<_o5>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s5>.PushNotNull(this);
                    }
                }
                private void _M5(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i5 inputParameter = new _i5();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                fastCSharp.threading.task.Tiny.Add(_s5/**/.GetCall(socket, _value_, ref inputParameter ));
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i6
                {
                    public fastCSharp.net.indexIdentity identity;
                    public fastCSharp.net.tcp.deployServer.directory directory;
                    public string serverPath;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o6 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o6 : fastCSharp.net.asynchronousMethod.IReturnParameter<int>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public int Ret;
                    public int Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (int)value; }
                    }
#endif
                }
                sealed class _s6 : fastCSharp.net.tcp.commandServer.serverCall<_s6, fastCSharp.net.tcp.deployServer, _i6>
                {
                    private void get(ref fastCSharp.net.returnValue<_o6> value)
                    {
                        try
                        {
                            
                            int Return;


                            
                            Return = serverValue.addWeb(inputParameter.identity, inputParameter.directory, inputParameter.serverPath);

                            value.Value = new _o6
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o6> value = new fastCSharp.net.returnValue<_o6>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s6>.PushNotNull(this);
                    }
                }
                private void _M6(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i6 inputParameter = new _i6();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                fastCSharp.threading.task.Tiny.Add(_s6/**/.GetCall(socket, _value_, ref inputParameter ));
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i7
                {
                    public fastCSharp.net.indexIdentity identity;
                    public fastCSharp.keyValue<string,int>[] files;
                    public string serverPath;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o7 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o7 : fastCSharp.net.asynchronousMethod.IReturnParameter<int>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public int Ret;
                    public int Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (int)value; }
                    }
#endif
                }
                sealed class _s7 : fastCSharp.net.tcp.commandServer.serverCall<_s7, fastCSharp.net.tcp.deployServer, _i7>
                {
                    private void get(ref fastCSharp.net.returnValue<_o7> value)
                    {
                        try
                        {
                            
                            int Return;


                            
                            Return = serverValue.addFiles(inputParameter.identity, inputParameter.files, inputParameter.serverPath);

                            value.Value = new _o7
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o7> value = new fastCSharp.net.returnValue<_o7>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s7>.PushNotNull(this);
                    }
                }
                private void _M7(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i7 inputParameter = new _i7();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                _s7/**/.Call(socket, _value_, ref inputParameter );
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i8
                {
                    public fastCSharp.net.indexIdentity identity;
                    public fastCSharp.keyValue<string,int>[] files;
                    public string serverPath;
                    public int runSleep;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o8 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o8 : fastCSharp.net.asynchronousMethod.IReturnParameter<int>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public int Ret;
                    public int Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (int)value; }
                    }
#endif
                }
                sealed class _s8 : fastCSharp.net.tcp.commandServer.serverCall<_s8, fastCSharp.net.tcp.deployServer, _i8>
                {
                    private void get(ref fastCSharp.net.returnValue<_o8> value)
                    {
                        try
                        {
                            
                            int Return;


                            
                            Return = serverValue.addRun(inputParameter.identity, inputParameter.files, inputParameter.serverPath, inputParameter.runSleep);

                            value.Value = new _o8
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o8> value = new fastCSharp.net.returnValue<_o8>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s8>.PushNotNull(this);
                    }
                }
                private void _M8(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i8 inputParameter = new _i8();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                _s8/**/.Call(socket, _value_, ref inputParameter );
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                internal struct _i9
                {
                    public fastCSharp.net.indexIdentity identity;
                    public int taskIndex;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o9 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o9 : fastCSharp.net.asynchronousMethod.IReturnParameter<int>
#endif
                {
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public int Ret;
                    public int Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (int)value; }
                    }
#endif
                }
                sealed class _s9 : fastCSharp.net.tcp.commandServer.serverCall<_s9, fastCSharp.net.tcp.deployServer, _i9>
                {
                    private void get(ref fastCSharp.net.returnValue<_o9> value)
                    {
                        try
                        {
                            
                            int Return;


                            
                            Return = serverValue.addWaitRunSwitch(inputParameter.identity, inputParameter.taskIndex);

                            value.Value = new _o9
                            {
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o9> value = new fastCSharp.net.returnValue<_o9>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s9>.PushNotNull(this);
                    }
                }
                private void _M9(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i9 inputParameter = new _i9();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                _s9/**/.Call(socket, _value_, ref inputParameter );
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false, IsReferenceMember = false)]
                internal struct _i10
                {
                    public ulong randomPrefix;
                    public byte[] md5Data;
                    public long ticks;
                }
                [fastCSharp.emit.dataSerialize(IsMemberMap = false, IsReferenceMember = false)]
                [fastCSharp.emit.boxSerialize]
#if NOJIT
                internal struct _o10 : fastCSharp.net.asynchronousMethod.IReturnParameter
#else
                internal struct _o10 : fastCSharp.net.asynchronousMethod.IReturnParameter<bool>
#endif
                {
                    public long ticks;
                    [fastCSharp.emit.jsonSerialize.member(IsIgnoreCurrent = true)]
                    [fastCSharp.emit.jsonParse.member(IsIgnoreCurrent = true)]
                    public bool Ret;
                    public bool Return
                    {
                        get { return Ret; }
                        set { Ret = value; }
                    }
#if NOJIT
                    public object ReturnObject
                    {
                        get { return Ret; }
                        set { Ret = (bool)value; }
                    }
#endif
                }
                sealed class _s10 : fastCSharp.net.tcp.commandServer.serverCall<_s10, fastCSharp.net.tcp.deployServer, _i10>
                {
                    private void get(ref fastCSharp.net.returnValue<_o10> value)
                    {
                        try
                        {
                            
                            bool Return;


                            
                            Return = serverValue.verify(socket, inputParameter.randomPrefix, inputParameter.md5Data, ref inputParameter.ticks);

                            if (Return) socket.SetVerifyMethod();
                            value.Value = new _o10
                            {
                                ticks = inputParameter.ticks,
                                Return = Return
                            };
                            value.Type = fastCSharp.net.returnValue.type.Success;
                        }
                        catch (Exception error)
                        {
                            value.Type = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    }
                    public override void Call()
                    {
                        fastCSharp.net.returnValue<_o10> value = new fastCSharp.net.returnValue<_o10>();
                        if (isVerify == 0)
                        {
                            get(ref value);
                            socket.SendStream(ref identity, ref value, flags);
                        }
                        fastCSharp.typePool<_s10>.PushNotNull(this);
                    }
                }
                private void _M10(socket socket, ref subArray<byte> data)
                {
                    fastCSharp.net.returnValue.type returnType = fastCSharp.net.returnValue.type.Unknown;
                        try
                        {
                            _i10 inputParameter = new _i10();
                            if ((socket.Flags & fastCSharp.net.tcp.commandServer.commandFlags.JsonSerialize) == 0 ? fastCSharp.emit.dataDeSerializer.DeSerialize(ref data, ref inputParameter) : fastCSharp.code.cSharp.tcpBase.JsonDeSerialize(ref inputParameter, ref data))
                            {
                                _s10/**/.Call(socket, _value_, ref inputParameter );
                                return;
                            }
                            returnType = fastCSharp.net.returnValue.type.ServerDeSerializeError;
                        }
                        catch (Exception error)
                        {
                            returnType = fastCSharp.net.returnValue.type.ServerException;
                            fastCSharp.log.Error.Add(error, null, true);
                        }
                    socket.SendStream(socket.Identity, returnType);
                }
            }

            /// <summary>
            /// TCP客户端
            /// </summary>
            public class tcpClient : fastCSharp.net.tcp.timeVerifyServer.ITimeVerifyClient, fastCSharp.net.tcp.commandClient.IClient
            {
                /// <summary>
                /// 时间验证服务客户端验证函数
                /// </summary>
#if NOJIT
                public sealed class timeVerifyMethod : fastCSharp.code.cSharp.tcpBase.ITcpClientVerifyMethodAsObject
                {
                    /// <summary>
                    /// 时间验证服务客户端验证函数
                    /// </summary>
                    /// <param name="client">TCP调用客户端</param>
                    /// <returns>是否通过验证</returns>
                    public bool Verify(object client)
                    {
                        return fastCSharp.net.tcp.timeVerifyServer.Verify((tcpClient)client);
                    }
                }
#else
                public sealed class timeVerifyMethod : fastCSharp.code.cSharp.tcpBase.ITcpClientVerifyMethod<tcpClient>
                {
                    /// <summary>
                    /// 时间验证服务客户端验证函数
                    /// </summary>
                    /// <param name="client">TCP调用客户端</param>
                    /// <returns>是否通过验证</returns>
                    public bool Verify(tcpClient client)
                    {
                        return fastCSharp.net.tcp.timeVerifyServer.Verify(client);
                    }
                }
#endif
                /// <summary>
                /// TCP调用客户端
                /// </summary>
                private fastCSharp.net.tcp.commandClient tcpCommandClient;
                /// <summary>
                /// TCP调用客户端
                /// </summary>
                public fastCSharp.net.tcp.commandClient TcpCommandClient { get { return tcpCommandClient; } }
                /// <summary>
                /// TCP调用客户端
                /// </summary>
                /// <param name="attribute">TCP调用服务器端配置信息</param>
                /// <param name="verifyMethod">TCP验证方法</param>
#if NOJIT
                public tcpClient(fastCSharp.code.cSharp.tcpServer attribute = null, fastCSharp.code.cSharp.tcpBase.ITcpClientVerifyMethodAsObject verifyMethod = null)
#else
                public tcpClient(fastCSharp.code.cSharp.tcpServer attribute = null, fastCSharp.code.cSharp.tcpBase.ITcpClientVerifyMethod<tcpClient> verifyMethod = null)
#endif
                {
                    tcpCommandClient = new fastCSharp.net.tcp.commandClient<tcpClient>(attribute ?? fastCSharp.code.cSharp.tcpServer.GetConfig("deploy", typeof(fastCSharp.net.tcp.deployServer)), 28, verifyMethod ?? new fastCSharp.net.tcp.deployServer.tcpClient.timeVerifyMethod(), this);
                }
                /// <summary>
                /// 释放资源
                /// </summary>
                public void Dispose()
                {
                    fastCSharp.pub.Dispose(ref tcpCommandClient);
                }


                /// <summary>
                /// 忽略TCP分组
                /// </summary>
                /// <param name="groupId">分组标识</param>
                /// <returns>是否调用成功</returns>
                public fastCSharp.net.returnValue.type TcpIgnoreGroup(int groupId)
                {
                    fastCSharp.net.tcp.commandClient client = TcpCommandClient;
                    return client == null ? fastCSharp.net.returnValue.type.ClientDisposed : client.IgnoreGroup(groupId);
                }

                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c0 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 0 + 128, MaxInputSize = 0, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue clear()
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall _wait_ = fastCSharp.net.waitCall.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.clear(null, _wait_, false);
                        fastCSharp.net.returnValue _returnValue_;
                        _wait_.Get(out _returnValue_);
                        return _returnValue_;
                    }
                    return new fastCSharp.net.returnValue{ Type = _returnType_ };
                }


                [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
                public void clear(Action<fastCSharp.net.returnValue> _onReturn_)
                {
                    
                    clear(_onReturn_, null, true);
                }
                private void clear(Action<fastCSharp.net.returnValue> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue _returnType_;
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            _socket_.Call(_onReturn_, _callback_, _c0, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c1 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 1 + 128, MaxInputSize = 0, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<fastCSharp.net.indexIdentity> create()
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o1> _wait_ = fastCSharp.net.waitCall<tcpServer._o1>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.create(null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o1> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<fastCSharp.net.indexIdentity>{ Type = _returnType_ };
                }


                private void create(Action<fastCSharp.net.returnValue<tcpServer._o1>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o1>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o1> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o1>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            _socket_.Get(_onReturn_, _callback_, _c1, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c2 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 2 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue clear(fastCSharp.net.indexIdentity identity)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall _wait_ = fastCSharp.net.waitCall.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.clear(identity, null, _wait_, false);
                        fastCSharp.net.returnValue _returnValue_;
                        _wait_.Get(out _returnValue_);
                        return _returnValue_;
                    }
                    return new fastCSharp.net.returnValue{ Type = _returnType_ };
                }


                [System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)fastCSharp.pub.MethodImplOptionsAggressiveInlining)]
                public void clear(fastCSharp.net.indexIdentity identity, Action<fastCSharp.net.returnValue> _onReturn_)
                {
                    
                    clear(identity, _onReturn_, null, true);
                }
                private void clear(fastCSharp.net.indexIdentity identity, Action<fastCSharp.net.returnValue> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue _returnType_;
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i2 _inputParameter_ = new tcpServer._i2
                            {
                                identity = identity,
                            };
                            _socket_.Call<tcpServer._i2>(_onReturn_, _callback_, _c2, ref _inputParameter_, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c3 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 3 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<bool> start(fastCSharp.net.indexIdentity identity, System.DateTime time)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o3> _wait_ = fastCSharp.net.waitCall<tcpServer._o3>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.start(identity, time, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o3> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<bool>{ Type = _returnType_ };
                }


                private void start(fastCSharp.net.indexIdentity identity, System.DateTime time, Action<fastCSharp.net.returnValue<tcpServer._o3>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o3>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o3> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o3>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i3 _inputParameter_ = new tcpServer._i3
                            {
                                identity = identity,
                                time = time,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c3, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c4 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 4 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<bool> setFileSource(fastCSharp.net.indexIdentity identity, byte[][] files)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o4> _wait_ = fastCSharp.net.waitCall<tcpServer._o4>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.setFileSource(identity, files, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o4> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<bool>{ Type = _returnType_ };
                }


                private void setFileSource(fastCSharp.net.indexIdentity identity, byte[][] files, Action<fastCSharp.net.returnValue<tcpServer._o4>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o4>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o4> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o4>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i4 _inputParameter_ = new tcpServer._i4
                            {
                                identity = identity,
                                files = files,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c4, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c5 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 5 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<fastCSharp.net.tcp.deployServer.directory> getFileDifferent(fastCSharp.net.tcp.deployServer.directory directory, string serverPath)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o5> _wait_ = fastCSharp.net.waitCall<tcpServer._o5>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.getFileDifferent(directory, serverPath, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o5> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<fastCSharp.net.tcp.deployServer.directory>{ Type = _returnType_ };
                }


                private void getFileDifferent(fastCSharp.net.tcp.deployServer.directory directory, string serverPath, Action<fastCSharp.net.returnValue<tcpServer._o5>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o5>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o5> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o5>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i5 _inputParameter_ = new tcpServer._i5
                            {
                                directory = directory,
                                serverPath = serverPath,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c5, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c6 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 6 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<int> addWeb(fastCSharp.net.indexIdentity identity, fastCSharp.net.tcp.deployServer.directory directory, string serverPath)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o6> _wait_ = fastCSharp.net.waitCall<tcpServer._o6>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.addWeb(identity, directory, serverPath, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o6> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<int>{ Type = _returnType_ };
                }


                private void addWeb(fastCSharp.net.indexIdentity identity, fastCSharp.net.tcp.deployServer.directory directory, string serverPath, Action<fastCSharp.net.returnValue<tcpServer._o6>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o6>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o6> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o6>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i6 _inputParameter_ = new tcpServer._i6
                            {
                                identity = identity,
                                directory = directory,
                                serverPath = serverPath,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c6, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c7 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 7 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<int> addFiles(fastCSharp.net.indexIdentity identity, fastCSharp.keyValue<string,int>[] files, string serverPath)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o7> _wait_ = fastCSharp.net.waitCall<tcpServer._o7>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.addFiles(identity, files, serverPath, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o7> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<int>{ Type = _returnType_ };
                }


                private void addFiles(fastCSharp.net.indexIdentity identity, fastCSharp.keyValue<string,int>[] files, string serverPath, Action<fastCSharp.net.returnValue<tcpServer._o7>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o7>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o7> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o7>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i7 _inputParameter_ = new tcpServer._i7
                            {
                                identity = identity,
                                files = files,
                                serverPath = serverPath,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c7, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c8 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 8 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<int> addRun(fastCSharp.net.indexIdentity identity, fastCSharp.keyValue<string,int>[] files, string serverPath, int runSleep)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o8> _wait_ = fastCSharp.net.waitCall<tcpServer._o8>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.addRun(identity, files, serverPath, runSleep, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o8> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<int>{ Type = _returnType_ };
                }


                private void addRun(fastCSharp.net.indexIdentity identity, fastCSharp.keyValue<string,int>[] files, string serverPath, int runSleep, Action<fastCSharp.net.returnValue<tcpServer._o8>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o8>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o8> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o8>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i8 _inputParameter_ = new tcpServer._i8
                            {
                                identity = identity,
                                files = files,
                                serverPath = serverPath,
                                runSleep = runSleep,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c8, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c9 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 9 + 128, MaxInputSize = 2147483647, IsKeepCallback = 0, IsSendOnly = 0 };

                public fastCSharp.net.returnValue<int> addWaitRunSwitch(fastCSharp.net.indexIdentity identity, int taskIndex)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o9> _wait_ = fastCSharp.net.waitCall<tcpServer._o9>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.addWaitRunSwitch(identity, taskIndex, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o9> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<int>{ Type = _returnType_ };
                }


                private void addWaitRunSwitch(fastCSharp.net.indexIdentity identity, int taskIndex, Action<fastCSharp.net.returnValue<tcpServer._o9>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o9>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o9> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o9>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.StreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i9 _inputParameter_ = new tcpServer._i9
                            {
                                identity = identity,
                                taskIndex = taskIndex,
                            };
                            _socket_.Get(_onReturn_, _callback_, _c9, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
                private static readonly fastCSharp.net.tcp.commandClient.identityCommand _c10 = new fastCSharp.net.tcp.commandClient.identityCommand { Command = 10 + 128, MaxInputSize = 1024, IsKeepCallback = 0, IsSendOnly = 0 };

                /// <summary>
                /// 时间验证函数
                /// </summary>
                /// <returns>是否验证成功</returns>
                public fastCSharp.net.returnValue<bool> verify(ulong randomPrefix, byte[] md5Data, ref long ticks)
                {
                    fastCSharp.net.returnValue.type _returnType_;
                    fastCSharp.net.waitCall<tcpServer._o10> _wait_ = fastCSharp.net.waitCall<tcpServer._o10>.Get();
                    if (_wait_ == null) _returnType_ = fastCSharp.net.returnValue.type.ClientException;
                    else
                    {
                        
                        this.verify(randomPrefix, md5Data, ref ticks, null, _wait_, false);
                        fastCSharp.net.returnValue<tcpServer._o10> _outputParameter_;
                        _wait_.Get(out _outputParameter_);
                        if (_outputParameter_.Type == fastCSharp.net.returnValue.type.Success)
                        {
                            ticks = _outputParameter_.Value.ticks;
                            return _outputParameter_.Value.Return;
                        }
                        _returnType_ = _outputParameter_.Type;
                    }
                    return new fastCSharp.net.returnValue<bool>{ Type = _returnType_ };
                }


                private void verify(ulong randomPrefix, byte[] md5Data, ref long ticks, Action<fastCSharp.net.returnValue<tcpServer._o10>> _onReturn_, fastCSharp.net.callback<fastCSharp.net.returnValue<tcpServer._o10>> _callback_, bool _isTask_)
                {
                    fastCSharp.net.returnValue<tcpServer._o10> _returnType_ = new fastCSharp.net.returnValue<tcpServer._o10>();
                    try
                    {
                        fastCSharp.net.tcp.commandClient.streamCommandSocket _socket_ = TcpCommandClient.VerifyStreamSocket;
                        if (_socket_ != null)
                        {
                            tcpServer._i10 _inputParameter_ = new tcpServer._i10
                            {
                                randomPrefix = randomPrefix,
                                md5Data = md5Data,
                                ticks = ticks,
                            };
                            _returnType_.Value.ticks = _inputParameter_.ticks;
                            _socket_.Get(_onReturn_, _callback_, _c10, ref _inputParameter_, ref _returnType_.Value, _isTask_);
                            return;
                        }
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientDisposed;
                    }
                    catch (Exception _error_)
                    {
                        _returnType_.Type = fastCSharp.net.returnValue.type.ClientException;
                        fastCSharp.log.Error.Add(_error_, null, false);
                    }
                    if (_callback_ != null) _callback_.Callback(ref _returnType_);
                    else if (_onReturn_ != null) _onReturn_(_returnType_);
                }
            }

        }
}
#endif